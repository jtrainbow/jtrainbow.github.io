<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jtrainbow.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="JTRAINBOWの博客">
<meta property="og:url" content="https://jtrainbow.github.io/index.html">
<meta property="og:site_name" content="JTRAINBOWの博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="JTRAINBOW">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jtrainbow.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JTRAINBOWの博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JTRAINBOWの博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JTRAINBOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/05/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-07 23:10:31" itemprop="dateCreated datePublished" datetime="2024-05-07T23:10:31+08:00">2024-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-21 17:06:58" itemprop="dateModified" datetime="2024-05-21T17:06:58+08:00">2024-05-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>微服务架构是把一个单体应用程序拆分成多个小型服务，每个服务运行在各自的进程中，并通过轻量级机制（REST、PRC）进行通信。这些服务按照业务功能构建，相互独立并且有尽可能低的关联性，可以使用不同的编程语言和数据存储技术实现，甚至可以通过全自动部署机制独立部署。</p>
<ol>
<li>REST：基于TCP的超文本传输协议（HTTP）的一种格式</li>
<li>PRC：基于二进制的远程调用协议</li>
<li>服务关联性：各个服务暴露自身API，其他服务按需调用</li>
</ol>
<h2 id="应用程序分类"><a href="#应用程序分类" class="headerlink" title="应用程序分类"></a>应用程序分类</h2><h3 id="普通单体应用系统"><a href="#普通单体应用系统" class="headerlink" title="普通单体应用系统"></a>普通单体应用系统</h3><ol>
<li>概念：所有代码都放在一个项目中，应用系统和存储系统都在同一个服务器</li>
<li>优点：项目前中期方便开发、测试和部署</li>
<li>缺点：项目后期代码量变得臃肿，导致开发效率低、维护困难，服务器资源压力增大，且任意功能出现重大漏洞和错误都会影响整体</li>
</ol>
<h3 id="分布式单体应用系统"><a href="#分布式单体应用系统" class="headerlink" title="分布式单体应用系统"></a>分布式单体应用系统</h3><ol>
<li>概念：所有代码都放在一个项目中，应用系统和存储系统分布在不同的服务器</li>
<li>优点：项目前中期方便开发、测试和部署</li>
<li>缺点：项目后期代码量变得臃肿，导致开发效率低、维护困难，服务器资源压力增大，且任意功能出现重大漏洞和错误都会影响整体</li>
</ol>
<h3 id="集群单体应用系统"><a href="#集群单体应用系统" class="headerlink" title="集群单体应用系统"></a>集群单体应用系统</h3><ol>
<li>概念：所有代码都放在一个项目中，应用系统和存储系统增加多个实例，分布在不同的服务器</li>
<li>优点：项目前中期方便开发、测试和部署，多个实例部署在不同服务器，通过负载均衡为所有服务器分摊压力</li>
<li>缺点：项目后期代码量变得臃肿，导致开发效率低、维护困难，任意实例出现重大漏洞和错误都会导致该实例不可用</li>
</ol>
<h3 id="垂直多服务应用系统"><a href="#垂直多服务应用系统" class="headerlink" title="垂直多服务应用系统"></a>垂直多服务应用系统</h3><ol>
<li>概念：将单体应用划分成多个小的服务模块，每个服务和存储系统增加多个实例，分布在不同的服务器</li>
<li>优点：多个实例部署在不同服务器，通过负载均衡为所有服务器分摊压力，方便对不同服务模块针对性优化和扩展</li>
<li>缺点：每个服务之间项目独立，无法通信，还可能会有重复的业务</li>
</ol>
<h3 id="分布式多服务应用系统"><a href="#分布式多服务应用系统" class="headerlink" title="分布式多服务应用系统"></a>分布式多服务应用系统</h3><ol>
<li>概念：将垂直应用系统中重复代码提取出来组成多个公共的服务模块，业务模块同一使用公共模块，应用系统和存储系统增加多个实例，分布在不同的服务器</li>
<li>优点：提高代码服用率</li>
<li>缺点：各个模块耦合度变高，调用关系复杂难以维护</li>
</ol>
<h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><ol>
<li>概念：面向服务架构，通过资源调度和治理中心（Service Oriented Architecture）对所有服务进行实时管理</li>
<li>优点：使用服务中心解决服务间的自动调节</li>
<li>缺点：需要维护服务中心（资源调度和治理），服务间有依赖性，某个节点出错会导致整个环节不可用（服务雪崩）</li>
</ol>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ol>
<li>概念：面向服务架构，但更强调业务功能的尽量拆分</li>
<li>优点：容易扩展、服务间耦合度低</li>
<li>缺点：开发成本高，需要考虑容错和分布式事务</li>
</ol>
<h2 id="微服务系统需要解决的问题"><a href="#微服务系统需要解决的问题" class="headerlink" title="微服务系统需要解决的问题"></a>微服务系统需要解决的问题</h2><ol>
<li>如何管理多个微服务：服务治理（注册、发现、移除）</li>
<li>服务之间如何通信：服务调用（REST、RPC）</li>
<li>客户端如何访问服务：服务网关（客户端-&gt;API网关-&gt;各个服务）</li>
<li>某个服务出现问题如何处理：服务容错（不被外界环境影响、不被上游服务请求压垮、不被下游服务响应拖垮）</li>
<li>某个服务出现问题如何排查：链路追踪（对一次请求涉及的所有服务进行日志记录和性能监控）</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li><code>ServiceComb</code>：前身是华为云的微服务引擎CSE(Cloud Service Engine)<br>云服务，是全球首个Apache微服务顶级项目。它提供了一站式的微服务开源解决方案，致力于帮助企业、用户和开发者将企业应用轻松微服务化上云，并实现对微服务应用的高效运维管理。</li>
<li><code>Spring Cloud</code>：<code>Spring Cloud</code>是一系列框架的集合。它利用<code>Spring Boot</code><br>的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务注册和发现、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用<code>Spring Boot</code>的开发风格做到一键启动和部署，<code>Spring Cloud</code><br>并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过<code>Spring Boot</code>风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</li>
<li><code>Spring Cloud Alibaba</code>：<code>Spring Cloud Alibaba</code>是<code>Spring Cloud</code><br>的扩展，致力于提供微服务开发的一站式解决方案，此项目包含开发分布式应用微服务的必需组件，方便开发者通过<code>Spring Cloud</code>编程模型轻松使用这些组件来开发分布式应用服务。</li>
<li><code>Dubbo + Zookeeper</code>：基于Java的高性能RPC分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</li>
</ol>
<h2 id="组件框架"><a href="#组件框架" class="headerlink" title="组件框架"></a>组件框架</h2><ol>
<li>治理中心（注册、发现、移除）：<code>Eureka</code>、<code>Zookeeper</code>、<code>Nacos</code>、<code>Consul</code></li>
<li>配置中心：<code>Config</code>、<code>Naocs</code></li>
<li>服务网关：<code>Zuul</code>、<code>Gateway</code></li>
<li>服务降级：<code>Hystrix</code>、<code>Sentinel</code>、<code>Resilience4j</code></li>
<li>服务总线：<code>Bus</code>、<code>Nacos</code></li>
<li>服务调用：<code>Ribbon</code>、<code>OpenFeign</code>、<code>RestTemplate</code></li>
<li>分布式事务：<code>Seata</code></li>
<li>自动部署：<code>Jenkins</code>、<code>Docker</code></li>
<li>链路追踪：<code>Sleuth Zipkin</code>、<code>SkyWalking</code></li>
</ol>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><ol>
<li>EurekaService：客户端服务注册、发现和移除</li>
<li>EurekaClient：既是服务提供者也是消费者，向服务中心注册，并拉取其他客户端信息<ul>
<li>消费者根据负载均衡策略选择一个服务者实例发起请求</li>
</ul>
</li>
</ol>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><ol>
<li>git：保存配置文件信息</li>
<li>ConfigService：自动从git获取最新配置文件信息并缓存</li>
<li>ConfigClient：<ul>
<li>手动调用<code>/actuator/refresh</code>获取ConfigService的配置信息并刷新配置</li>
<li>如果集成了<code>Bus</code>，ConfigService可以自动通知ConfigClient刷新配置</li>
</ul>
</li>
</ol>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><ol>
<li>注册流程<ul>
<li>启动注册中心，在配置中心写入配置信息，持久化到磁盘并与集群的其他注册中心同步配置信息</li>
<li>客户端启动时发起注册请求，从配置中心拉取配置并缓存到本地，获取可用服务的实例列表</li>
<li>服务中心将客户端服务的名称、地址、端口号等信息存入注册表并生成唯一ID</li>
<li>服务调用：每个客户端既是服务提供者也是服务消费者<ul>
<li>服务消费者根据Nacos负载均衡策略选择一个服务提供者发起调用请求</li>
<li>服务提供者收到请求后处理并返回响应结果</li>
</ul>
</li>
<li>配置变更时，通知对应的客户端重新拉取配置信息并刷新</li>
</ul>
</li>
<li>配置中心<ul>
<li>发布与订阅：开发者可以将配置信息发布到 Nacos 配置中心，并订阅自己关心的配置信息</li>
<li>变更通知：当配置信息发生变化时，Nacos 配置中心会主动推送变更通知给订阅者</li>
<li>版本管理：Nacos支持配置的版本管理，方便开发者回滚到之前的配置版本</li>
<li>分组与标签：Nacos支持配置的分组和标签功能，方便开发者对配置进行分类和管理</li>
<li>加密与解密：Nacos支持对敏感配置信息进行加密和解密操作，保证配置信息的安全性</li>
<li>持久化：配置信息持久化到磁盘</li>
<li>集群：多个Nacos服务之间通过Raft协议同步数据，保证数据一致性</li>
<li>健康检测：定期检测配置信息，自动摘除不健康的配置信息</li>
<li>备份与恢复：支持配置信息导入导出和定期远程备份</li>
</ul>
</li>
<li>数据模型<ul>
<li><code>Namespace</code>：命名空间，用于隔离不同环境的配置信息</li>
<li><code>Config</code>：配置项，包含配置键、配置值、配置描述等信息，一个配置项可以属于多个命名空间</li>
<li><code>Group</code>：配置分组，对配置项进行分组管理</li>
<li><code>Tag</code>：标签，对配置项进行标记和分类</li>
<li><code>Instance</code>：实例，包含地址、端口号、权重、健康状态等信息，一个实例只属于一个服务</li>
<li><code>Service</code>：服务，包含一个唯一的服务名称，一个服务可以有多个实例</li>
</ul>
</li>
<li>负载均衡和服务治理<ul>
<li>负载均衡：支持轮询、加权、随机、最小连接等负载均衡策略</li>
<li>服务鉴权：支持基于<code>AccessKey</code>和<code>SecretKey</code>的鉴权机制，保证服务调用的安全性</li>
<li>限流熔断：支持基于令牌桶和漏桶算法的限流策略，以及基于<code>Hystrix</code>的熔断策略，保证服务调用的稳定性</li>
<li>路由策略：支持基于权重、标签、元数据等属性的路由策略，实现服务的灵活调度</li>
<li>服务灰度：支持基于流量分组的灰度发布策略，实现服务的平滑升级</li>
</ul>
</li>
</ol>
<h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><ol>
<li><code>RestTemplate</code>：基于HTTP的远程服务调用</li>
<li>负载均衡：发起远程服务调用时，由Ribbon获取服务列表并根据规则选择某个具体的服务发起调用<ul>
<li>简单轮询、忽略连接失败或并发量高的服务、根据服务响应时间加权、Zone分区、随机</li>
</ul>
</li>
<li>重试机制：自身实例重试后选择其他实例</li>
</ol>
<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>基于注解的声明式Web服务客户端，通过注解和接口的形式来绑定服务端，简化了客户端与远程Http服务的交互过程。</p>
<ol>
<li>声明式接口编程，远程调用被抽象成接口调用<ul>
<li>通过<code>@EnableFeignClients</code>注解启动Feign客户端</li>
<li>通过在接口上标注<code>@FeignClient</code>注解绑定远程服务</li>
<li>接口方法上使用<code>@RequestMapping</code>注解绑定远程服务的具体API</li>
</ul>
</li>
<li>自动构建HTTP请求和解析HTTP响应<ul>
<li>自定义请求拦截器：实现<code>RequestInterceptor</code>接口的<code>apply()</code>，传递token等参数</li>
<li><code>fallback</code>：降级处理</li>
<li><code>fallbackFactory</code>：降级处理，并可以记录导致降级的异常原因</li>
</ul>
</li>
<li>负载均衡：集成Ribbon<ul>
<li>服务发现：从服务中心获取了服务的所有实例</li>
<li>请求拦截：发送请求时转发给Ribbon，由Ribbon负载均衡策略发送给具体的实例，最后返回响应</li>
</ul>
</li>
<li>熔断&#x2F;重试：集成Hystrix&#x2F;Resilience4j&#x2F;Spring Retry&#x2F;Sentinel<ul>
<li>通过<code>@EnableHystrix</code>&#x2F;<code>@EnableRetry</code>注解开启功能</li>
<li>配置熔断&#x2F;重试参数</li>
</ul>
</li>
<li>数据压缩：配置服务端和客户端支持GZIP</li>
<li>连接池：引入<code>feign-httpclient</code>依赖并配置连接池参数</li>
<li>日志：配置全局日志和服务日志级别</li>
</ol>
<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>网关作为微服务系统的统一入口，提供了身份认证、权限校验、服务路由、负载均衡、请求限流、跨域的功能。</p>
<p>Gateway基于WebFlux响应式编程，用于网络请求的转发，可以使用默认和自定义过滤器过滤请求，且不会影响接口原来的功能。</p>
<ol>
<li>使用：网关从配置中心获取服务列表，根据路由规则转发请求到指定服务，并可以配置规则过滤请求。<ul>
<li>引入网关和服务发现依赖<ul>
<li><code>spring-cloud-starter-gateway</code></li>
<li><code>spring-cloud-starter-alibaba-nacos-discovery</code></li>
</ul>
</li>
<li>配置服务中心地址、路由、过滤器、跨域：<ul>
<li><code>spring.cloud.nacos.server-addr</code></li>
<li><code>spring.cloud.gateway.routes</code></li>
<li><code>spring.cloud.gateway.filters</code></li>
<li><code>spring.cloud.gateway.globalcors</code></li>
</ul>
</li>
</ul>
</li>
<li>请求限流<ul>
<li>计数器算法：固定时间内处理固定数量的请求，请求到达上线就会被丢弃，直到计数器清零</li>
<li>漏桶算法：所有请求加入桶，桶以固定速度执行请求；桶满则丢弃多余请求，桶空则停止执行</li>
<li>令牌桶算法：以固定速度向桶中加入令牌，请求必须获得令牌才能执行；桶满丢弃多余令牌，桶空丢弃多余请求</li>
<li>通过<code>reactor.Mono</code>可实现针对URL、IP、用户的限流</li>
</ul>
</li>
<li>路由<ul>
<li>id：自定义的路由id，全局唯一即可</li>
<li>uri：路由目标，路由目标，<a href="http://ip:port表示固定地址，lb://service表示负载均衡">http://ip:port表示固定地址，lb://service表示负载均衡</a></li>
<li>predicates：路由断言，十多种，如路径断言（Path）、时间断言（After、Before、Between）、IP断言（RemoteAddr）、请求断言（Cookie、Header、Host、Method、Query）</li>
<li>filters：路由过滤器</li>
</ul>
</li>
<li>路由过滤器：Gateway提供31种路由过滤器，可以处理单个路由或所有路由<ul>
<li>*Header：可在请求和响应的header中添加或移除属性</li>
<li>RequestRateLimiter：限制请求的流量</li>
<li>过滤器链顺序：Order越小优先级越高，Order相同默认过滤器-&gt;路由过滤器-&gt;全局过滤器</li>
</ul>
</li>
</ol>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>用于微服务流量控制的组件，提供可视化控制台、熔断降级、限流和自定义扩展等功能。</p>
<ol>
<li>集成<ul>
<li>引入依赖：<code>spring-cloud-starter-alibaba-sentinel</code></li>
<li>配置参数：<ul>
<li><code>spring.cloud.sentinel.transport.dashboard: localhost:port</code></li>
<li><code>spring.cloud.sentinel.transport.dashboard.auth.username</code></li>
<li><code>spring.cloud.sentinel.transport.dashboard.auth.password</code></li>
<li><code>spring.cloud.sentinel.transport.dashboard.auth.password</code></li>
</ul>
</li>
</ul>
</li>
<li>簇点链路：一个请求的调用链路，链路中每个接口都是一个资源，流控、熔断等都是针对资源设置规则的</li>
<li>流控模式：针对资源设置QPS（每秒处理的请求数）阈值规则来流控<ul>
<li>直接：针对一个资源</li>
<li>关联：针对关联资源，A关联B，B触发阈值后会触发A的流控</li>
<li>链路：针对资源的指定入口资源</li>
</ul>
</li>
<li>流控效果：资源触发阈值后的处理<ul>
<li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常</li>
<li>预热：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常，但阈值会逐渐增大</li>
<li>排队：让所有的请求按照先后次序排队执行，等待超时的请求会被拒绝并抛出异常</li>
</ul>
</li>
<li>线程隔离和降级熔断：当微服务调用链某个节点出现问题时，会导致上游节点甚至是整个环节不可用，从而导致服务雪崩，解决方法有线程隔离和降级熔断，以此保护上游节点<ul>
<li>线程隔离：基于线程池隔离或信号量隔离，保证上游节点不会将全部线程用于一个下游节点</li>
<li>降级熔断：由断路器统计某个服务调用的异常比例、慢请求比例，超过阈值则认为服务不可用并触发熔断，即拦截所有对该服务的请求，只尝试放行一次请求直到服务可用或到达熔断时长才放行所有请求</li>
</ul>
</li>
<li>熔断策略<ul>
<li>慢调用比例：固定时间内请求数量、业务响应时长超过阈值</li>
<li>异常比例：固定时间请求数量、异常请求比例超过阈值</li>
<li>异常数：固定时间请求数量、异常请求数量超过阈值</li>
</ul>
</li>
<li>授权规则：黑、白名单，指定哪些来源的请求（网关、浏览器）可以访问服务<ul>
<li>通过实现<code>RequestOriginParser.parseOrigin()</code>获取<code>origin</code>请求来源</li>
</ul>
</li>
<li>自定义异常提示：默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方<ul>
<li>通过实现<code>BlockExceptionHandler.handle()</code>可返回自定义异常提示信息</li>
<li><code>FlowException</code>：限流异常</li>
<li><code>ParamFlowException</code>：热点参数限流异常</li>
<li><code>DegradeException</code>：降级异常</li>
<li><code>AuthorityException</code>：授权规则异常</li>
<li><code>SystemBlockException</code>：系统规则异常</li>
</ul>
</li>
<li>规则管理模式<ul>
<li>原始模式：将规则推送至客户端，只更新到内存中</li>
<li>Pull模式：将规则推送至客户端，除了更新到内存中，还会持久化到数据库或者磁盘文件</li>
<li>Push模式：将规则推送至配置中心（Nacos、Zookeeper），客户端通过注册监听器的方式时刻监听配置中心的通知</li>
</ul>
</li>
</ol>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>服务降级熔断防止服务雪崩</p>
<ol>
<li>开启功能：引入<code>spring-cloud-starter-hystrix</code>依赖，使用<code>@EnableHystrix</code>注解</li>
<li>开启可视化：引入<code>spring-cloud-starter-hystrix-dashboard</code>依赖，使用<code>@EnableHystrixDashboard</code>注解</li>
<li>指定接口方法熔断：<code>@HystrixCommand(fallbackMethod = &quot;hystrixMethod&quot;)</code></li>
<li>指定接口所有方法：引入OpenFeign依赖，配置fallbackFactory</li>
</ol>
<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><ol>
<li>事务管理<ul>
<li>TC（Transaction Coordinate）：事务协调者，维护全局和分支事务的状态，协调全局事务提交或回滚</li>
<li>TM（Transaction Manager）：事务管理器，定义全局事务的范围，开启、提交、回滚全局事务</li>
<li>RM（Resource Manager）：资源管理器，管理分支事务处理的资源，向TC注册分支事务和报告分支事务的状态，驱动分支事务提交或回滚</li>
</ul>
</li>
<li>分布式事务模式<ul>
<li>XA模式：强一致性分阶段事务模式，牺牲了可用性，无业务入侵</li>
<li>TCC模式：最终一致性分阶段事务模式，有业务入侵</li>
<li>AT模式：默认模式，最终一致性分阶段事务模式，无业务入侵</li>
<li>SAGA模式：长事务模式，有业务入侵</li>
</ul>
</li>
<li>XA模式：遵循XA规范的分阶段提交的分布式事务模型<ul>
<li>XA规范：一种分布式事务处理的标准，定义了TC、TM和RM之间的标准接口来实现分布式事务的提交和回滚，几乎所有主流数据库都支持XA规范</li>
<li>第一阶段：<ul>
<li>TM向TC注册全局事务，调用分支微服务事务</li>
<li>微服务通过RM锁定自身资源，向TC注册分支事务，并执行各自的事务SQL</li>
<li>分支事务结束后不会立即提交或回滚，而是向TC报告分支事务执行状态</li>
</ul>
</li>
<li>第二阶段：<ul>
<li>分支事务方法结束，TM提交或回滚全局事务</li>
<li>TC根据分支事务状态通知RM提交或回滚分支事务（如果全部成功则提交，如果有失败则回滚）</li>
</ul>
</li>
<li>优点：强一致性，满足ACID原则；主流数据库支持XA模式，实现简单且无业务入侵</li>
<li>缺点：分支事务开始后RM会锁定数据库资源，等到TC决定提交或回滚时才释放，性能较差；依赖关系数据库的事务</li>
</ul>
</li>
<li>AT模式：分阶段提交的分布式事务模型，不过优化了XA模式资源锁定周期过长带来的性能问题<ul>
<li>第一阶段：<ul>
<li>TM向TC注册全局事务，调用分支微服务事务<ul>
<li>微服务通过RM锁定自身资源，向TC注册分支事务，并记录资源的<code>undo log</code>快照，执行各自的事务SQL</li>
<li>分支事务结束后立即提交或回滚，并向TC报告分支事务执行状态</li>
</ul>
</li>
</ul>
</li>
<li>第二阶段：<ul>
<li>分支事务方法结束，TM提交或回滚全局事务</li>
<li>TC根据分支事务状态通知RM提交或回滚分支事务（如果全部成功则提交，如果有失败则回滚）</li>
<li>分支事务在一阶段已经完成提交&#x2F;回滚，这里的提交是指删除快照，回滚是指根据快照恢复数据</li>
</ul>
</li>
<li>脏写问题：全局事务1回滚导致全局事务2或非全局事务提交的修改失效</li>
<li>解决脏写：写隔离<ul>
<li>全局锁&#x2F;行级锁：全局事务的分支事务一阶段结束需要获取全局锁才能进入二阶段，否则回滚</li>
<li>记录分支事务执行前后的快照，二阶段回滚恢复数据时比较当前数据和快照数据，不一致则发出预警需要人工介入</li>
</ul>
</li>
<li>优点：写隔离；及时释放锁定的资源，性能较好；实现简单且无业务入侵</li>
<li>缺点：软一致性，第二阶段结束状态才最终一致；快照功能有极小的性能影响</li>
<li>实现：需要在TC服务数据库增加全局锁表（lock_table）、在微服务数据库增加快照表（undo_log）</li>
</ul>
</li>
<li>TCC模式：与AT模式类似，但由业务入侵，即需要编码补偿机制实现全局事务的提交或回滚<ul>
<li>补偿机制：<ul>
<li>Try：资源检测和预留，完成业务操作</li>
<li>Confirm：删除预留记录；默认Try成功Confirm一定能成功</li>
<li>Cancel：释放预留资源，恢复业务操作</li>
</ul>
</li>
<li>第一阶段：<ul>
<li>TM向TC注册全局事务，调用分支微服务事务</li>
<li>分支事务向TC注册分支事务，再Try资源预留，并向TC报告分支事务状态</li>
</ul>
</li>
<li>第二阶段：<ul>
<li>分支事务方法结束，TM提交或回滚全局事务</li>
<li>TC根据分支事务状态通知RM执行Confirm提交或Cancel回滚分支事务（如果全部成功则提交，如果有失败则回滚）</li>
</ul>
</li>
<li>问题：<ul>
<li>幂等性：Confirm&#x2F;Cancel失败或因网络问题导致没有收到RM返回通知，TC会重试Confirm&#x2F;Cancel</li>
<li>悬挂：cancel比try先执行，导致try的资源无法cancel</li>
<li>空回滚：在没有Try参与的情况下执行了Cancel</li>
</ul>
</li>
<li>解决方案：新增TCC事务控制表tcc_fence_log，包括一个状态字段status<ul>
<li>tcc_fence_log：Try成功插入一条记录</li>
<li>status：1（tried）、2（committed）、3（rollbacked）、status字段增加状态：4（suspended）</li>
<li>一阶段Try设置1，二阶段Confirm&#x2F;Cancel成功从1设置成2&#x2F;3，重复调用时判断状态即可</li>
<li>Cancel时先于Try设置成4，后续try判断是4就失败</li>
<li>Cancel时判断是否有记录来确定是否有Try</li>
</ul>
</li>
<li>优点：不需要全局锁和快照，及时释放锁定的资源，性能最好</li>
<li>缺点：软一致性，第二阶段结束状态才最终一致；实现复杂且有业务入侵</li>
<li>实现：需要在微服务数据库增加TCC事务控制表（tcc_fence_log）<ul>
<li><code>@GlobalTransactional</code>、<code>@Transactional</code>、<code>@LocalTCC</code></li>
<li><code>@TwoPhaseBusinessAction(name = &quot;tryMethod&quot;, commitMethod = &quot;commitMethod&quot;, rollbackMethod = &quot;rollbackMethod&quot;, useTCCFence = true)</code></li>
</ul>
</li>
</ul>
</li>
<li>SAGA模式：分阶段长事务解决方案<ul>
<li>补偿机制：状态机+DSL-JSON&#x2F;拦截器+注解</li>
<li>第一阶段：直接提交本地事务</li>
<li>第二阶段：如果失败通过补偿机制来回滚</li>
<li>优点：一阶段直接提交分支事务，无锁；基于事件驱动的异步调用；有业务入侵但实现简单</li>
<li>缺点：分支事务状态持续时间不确定，时效性差；可能有脏写；引入状态机有业务入侵</li>
</ul>
</li>
<li>集成：引入<code>spring-cloud-starter-alibaba-seata</code>依赖，nacos配置seata-tc-service，发起全局事务的入口方法上使用<code>@GlobalTranscation</code>注解，</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT-GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-service</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">SH</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA/AT/TCC/SAGA</span></span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>基于Java+观察者模式开发的面向分布式应用程序的分布式服务管理框架，它设计了一种类似文件目录树状结构的数据模型，存储和管理客户端服务的数据信息，并且接受观察者的注册，一旦观察者关心的数据发生变化，就会发出通知让对应的观察者作出反应，从而实现数据发布&#x2F;订阅、配置维护、分布式协调、集群、分布式锁&#x2F;队列等高级功能。</p>
<ol>
<li>支持单机版和一主多从集群，集群功能要有半数以上节点存活才能正常服务，所以集群节点数量适合奇数</li>
<li>集群每个节点都保存一份相同的数据副本，客户端无论连接到哪个节点，在一定时间范围内获取的数据都是一致的</li>
<li>来自同一个客户端的更新请求按照发送顺序依次执行</li>
</ol>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li><code>zxid</code>：zk中每个状态变化都会产生一个全局唯一的事务id，包括集群选主纪元（epoch）和一个十六进制计数器，每个更新操作根据请求顺序分配一个<code>zxid</code>，计数器数值小的先执行</li>
<li><code>version numbers</code>：zk中有三种版本号，每次ZNode状态更改都会增加其中一个版本值<ul>
<li><code>cversion</code>：当前ZNode的子ZNode变化时+1</li>
<li><code>dataVersion</code>：当前ZNode的数据每次变化时+1</li>
<li><code>aclVersion</code>：当前ZNode的acl权限每次变化时+1</li>
</ul>
</li>
<li><code>ticks</code>：zk的基本时间单位，默认2000ms</li>
<li><code>acl</code>：Access Control List，ZNode访问控制列表，格式是<code>scheme:id:permission</code>，对应访问策略、访问模式、访问权限（create、delete、read、write、admin）<ul>
<li><code>world</code>：默认策略，不验证可访问，<code>world:anyone:cdrwa</code></li>
<li><code>digest</code>：用户名和密码签名认证策略，<code>desgin:username:BASE64(SHA1(password)):cdrwa</code></li>
<li><code>auth</code>：用户名+密码身份验证策略，<code>auth:username:password:cdrwa</code></li>
<li><code>ip</code>：ip认证策略，<code>ip:127.0.0.1:cdrwa</code></li>
</ul>
</li>
</ol>
<h4 id="zk组成"><a href="#zk组成" class="headerlink" title="zk组成"></a>zk组成</h4><ol>
<li>单机版：<ul>
<li><code>server</code>：负责接收客户端请求并返回响应，处理更新操作</li>
<li><code>client</code>：发起请求</li>
</ul>
</li>
<li>集群：<ul>
<li><code>server leader</code>：负责投票、决议和更新服务端状态，处理更新操作</li>
<li><code>server follower</code>：接收客户端非事务请求并返回响应，转发事务请求给leader处理，参与投票</li>
<li><code>server observer</code>：接收客户端非事务请求并返回响应，转发事务请求给leader处理，监听leader变化，自动读取并更新数据，不参与投票</li>
<li><code>client</code>：发起请求</li>
</ul>
</li>
</ol>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>类似文件目录树状结构的数据模型，节点称作ZNode，既可以是目录也可以是数据存储器，最大存储容量是1M，操作ZNode时必须是以&#x2F;开头的绝对路径，并且ZNode数据更新操作具有原子性，其数据结构由ZNode状态、ZNode关联的数据、子ZNode组成，主要有以下属性：</p>
<ol>
<li><code>cZxid</code>：ZNode被创建时的事务id</li>
<li><code>ctime</code>：ZNode的创建时间</li>
<li><code>mZxid</code>：ZNode最后一次更改时的事务id</li>
<li><code>mtime</code>：ZNode最后一次更改的时间</li>
<li><code>pZxid</code>：子ZNode列表最后一次更改时的事务id</li>
<li><code>cversion</code>：子ZNode更改次数</li>
<li><code>dataVersion</code>：子ZNode内容更改次数</li>
<li><code>aclVersion</code>：ZNode的acl权限更改次数</li>
<li><code>ephemeralOwner</code>：默认0，如果是临时ZNode则表示绑定的session-id</li>
<li><code>dataLength</code>：ZNode关联的数据大小</li>
<li><code>numChildren</code>：子ZNode数量</li>
</ol>
<h4 id="ZNode类型"><a href="#ZNode类型" class="headerlink" title="ZNode类型"></a>ZNode类型</h4><p>当客户端连接到服务端后，可以CURD服务端的ZNode，根据<code>create [-e] [-s] path value acl</code><br>命令或API创建四种不同类型的ZNode：persistent、ephemeral、persistent_sequential、ephemeral_sequential</p>
<ol>
<li><code>-e</code>：临时，连接断开就会删除</li>
<li><code>-s</code>：永久，连接断开不会删除</li>
<li><code>path</code>：绝对路径</li>
<li><code>value</code>：顺序标识，设置后ZNode名称后会附加一个由父ZNode计数器维护的序列号，记录了子ZNode节点的创建顺序，可用于分布式系统的全局排序，同一连接不同ZNode的序列号相同</li>
<li><code>acl</code>：权限</li>
</ol>
<h4 id="全局Session"><a href="#全局Session" class="headerlink" title="全局Session"></a>全局Session</h4><p>客户端与服务器基于TCP长连接，每次客户端建立连接时服务端都创建一个session会话</p>
<ol>
<li>session状态<ul>
<li>创建初期短暂的connecting</li>
<li>创建成功后的connected</li>
<li>session关闭后的closed</li>
</ul>
</li>
<li>数据结构<ul>
<li><code>sessionId</code>：服务端全局唯一的会话id，可用于绑定临时ZNode</li>
<li><code>timeout</code>：会话超时时间</li>
<li><code>ticktime</code>：下次会话超时时间</li>
<li><code>isClosing</code>：session是否关闭</li>
</ul>
</li>
</ol>
<h4 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h4><p>zk的监听机制主要用于及时通知，可以实现发布&#x2F;订阅、分布式锁功能，当客户端在服务端注册监听器监听指定的ZNode后，一旦ZNode发生变化时，服务端会通知所有订阅客户端完成异步回调处理。</p>
<ol>
<li>命令<ul>
<li><code>ls -w path</code>：监听ZNode路径变化，只能监听ZNode本身和子ZNode，不能监听孙子ZNode</li>
<li><code>get -w path</code>：监听ZNode数据变化</li>
</ul>
</li>
<li>API：通过Watcher对象封装事件，客户端保存Watcher和ZNode回调处理的关系，服务端保存Watcher和ZNode事件触发的关系<ul>
<li><code>keeperState</code>：通知状态</li>
<li><code>EventType</code>：事件类型</li>
<li><code>path</code>：ZNode路径</li>
</ul>
</li>
<li>一次性：监听器触发后就会移除，即只会触发一次，想要持久监听需要触发后再监听<ul>
<li>确保监听事件只会触发一次，避免重复处理；永久性监听器有资源消耗；实现简单提高可靠性和稳定性</li>
</ul>
</li>
<li>流程<ul>
<li>启动zk客户端时会创建两个线程，一个负责网络通信（connect），一个负责监听（listener）</li>
<li>connect线程负责向zk服务端注册监听器（Watcher）</li>
<li>zk服务端将监听事件注册到监听器列表</li>
<li>另一个zk客户端修改了ZNode</li>
<li>zk服务端监听到ZNode变化，将消息异步发送给zk客户端listener线程，同时移除监听器</li>
<li>listener线程内部调用process方法执行监听触发后的处理，有需要则再次注册监听器</li>
</ul>
</li>
<li>发布&#x2F;订阅<ul>
<li>订阅：多个消费者客户端注册某个ZNode监听器</li>
<li>发布：多个生成者客户端更改ZNode</li>
</ul>
</li>
<li>分布式锁<ul>
<li><p>多个客户端向某个ZNode下创建有序临时ZNode，并判断自己的顺序</p>
</li>
<li><p>如果是第一位：获取到锁，执行业务逻辑，删除自身子ZNode来释放锁</p>
</li>
<li><p>如果不是第一位：监听前一位ZNode的删除事件并阻塞</p>
</li>
<li><p>监听到前一位ZNode删除事件，获取到锁</p>
</li>
<li><p>多个客户端竞争锁，向zf服务端创建同一个临时ZNode（锁节点）</p>
</li>
<li><p>如果创建成功，说明获取到锁</p>
</li>
<li><p>如果创建失败，说明没有获取到锁，需要注册锁节点删除事件并阻塞</p>
</li>
<li><p>监听到锁节点删除事件，被唤醒重新竞争锁</p>
</li>
</ul>
</li>
</ol>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><ol>
<li>ZAB协议：Zookeeper Atomic Broadcast，zk原子广播，是zk专门设计的支持崩溃恢复和主从同步的协议<ul>
<li><code>Looking</code>：选举状态</li>
<li><code>Following</code>：从节点状态</li>
<li><code>Leading</code>：主节点状态</li>
<li><code>observering</code>：观察者节点状态</li>
</ul>
</li>
<li>崩溃恢复（选举机制）：当主节点失效，集群失去服务能力，会选出新的主节点<ul>
<li>选举阶段：选出最大<code>zxid</code>的节点<ul>
<li>从节点都处于Looking状态，并向其他从节点发起投票（myid和最新<code>zxid</code>）</li>
<li>比较自身<code>zxid</code>和其他从节点投票中的<code>zxid</code>，如果自身的较小则重新发起投票（最大<code>zxid</code>和对应的myid），自身选举纪元（epoch）+1</li>
<li>每次投票统计投票数量，如果存在获得半数以上票数的从节点，那这个从节点状态改为leading成为准主节点，其他从节点状态改为following成为准从节点</li>
</ul>
</li>
<li>发现阶段：重新在从节点中找到最新的<code>zxid</code>，防止因网络原因等意外情况在选举阶段产生多个主节点<ul>
<li>following节点发送各自epoch给leading节点，leading节点选出最大的epoch，+1并分发给following节点</li>
<li>following节点收到最新epoch，返回各自最大<code>zxid</code>和历史事务日志</li>
<li>leading节点选出最大<code>zxid</code>节点，如果有比自身还大的则获取历史事务日志</li>
</ul>
</li>
<li>同步阶段：选出最终主节点<ul>
<li>leading节点将最新事务日志同步给所有following节点</li>
<li>只有半数以上的following节点同步成功成为从节点，leading节点才正式成为主节点</li>
</ul>
</li>
<li>广播阶段：正式对外提供服务，主节点广播消息同步数据<ul>
<li>zk的ZAB协议故障恢复完成之前，zk集群无法使用，即牺牲可用性保证数据一致性（CP）</li>
</ul>
</li>
</ul>
</li>
<li>写操作流程：主从同步，不能保证数据强一致性<ul>
<li>客户端发出写入数据请求，如果发给任意follower，follower把写入数据请求转发给leader处理</li>
<li>leader采用二阶段提交方式，先发送提案广播消息给follower</li>
<li>follower接到提案广播消息，写入日志成功后，返回ACK消息给leader</li>
<li>leader接到半数以上ACK消息，返回成功给客户端，并且广播commit消息给follower</li>
</ul>
</li>
<li>集群脑裂：发生网络分区导致出现多个主节点，一部分客户端连接了新主节点，另一部分还连接着旧主节点<ul>
<li>解决方案：过半机制，选举时必须是observer除外的所有服务端节点数量的一半以上选出主节点，因此集群节点数量必须是奇数</li>
</ul>
</li>
</ol>
<h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><ol>
<li>服务端：Zookeeper服务端通常从官网下载并解压运行，其配置位于Conf目录下的zoo.cfg文件中<ul>
<li><code>tickTime</code>：服务端与客户端的通信心跳时间</li>
<li><code>dataDir</code>：保存客户端数据快照文件的目录，集群模式下需要创建<code>myid</code>文件，内容是255以内的数字，表示节点的id</li>
<li><code>dataLogDir</code>：保存服务端日志文件的目录</li>
<li><code>ClientPort</code>：服务端端口号，默认2181</li>
<li><code>initLimit</code>：集群模式下首次启动时主从同步通信的时间次数，超时时间为initLimit * tickTime</li>
<li><code>syncLimit</code>：集群模式下非首次启动时主从异步通信的时间次数，超时时间为syncLimit * tickTime</li>
<li><code>server.id=ip:port1:port2:[observer]</code>：集群模式下所有节点的配置，id是<code>myid</code><br>文件内容，port1主从节点交换数据的端口，port2是集群选主的端口，observer表示该节点是observer类型</li>
</ul>
</li>
<li>命令<ul>
<li>启动、停止、状态检查命令：<code>zkServer.sh start/stop/status</code></li>
<li>启动命令：<code>zkServer.sh start-foreground</code>，输出日志</li>
<li>连接命令：<code>ZkClient.sh -server ip:port [ip1:port1...]</code>，随机连接一个节点</li>
<li>服务端命令<ul>
<li><code>conf</code>：zk服务配置的详细信息</li>
<li><code>stat</code>：客户端与zk连接的简要信息</li>
<li><code>srvr</code>：zk服务的详细信息</li>
<li><code>cons</code>：客户端与zk连接的详细信息</li>
<li><code>mntr</code>：zk服务目前的性能状况</li>
<li><code>wchs</code>：watch的简要信息</li>
<li><code>wchc</code>：watch的详细信息，客户端到watch的映射</li>
<li><code>wchp</code>：watch的详细信息，ZNode到watch的映射</li>
<li><code>help</code>：输出zk支持的所有命令</li>
<li>ZNode相关的命令：ls、create、get、set、delete、getAcl、setAcl等</li>
</ul>
</li>
</ul>
</li>
<li>客户端：引入<code>zookeeper</code>客户端依赖并配置服务端地址</li>
<li>客户端：引入<code>ZkClient</code>依赖（zk客户端）并配置服务端地址</li>
<li>客户端：引入<code>Curator</code>依赖（zk客户端）并配置服务地址<ul>
<li><code>curator-client</code>：zk基础客户端实现，如连接、重试、超时处理等</li>
<li><code>curator-framework</code>：包含高层级流式API，构建在基础客户端之上</li>
<li><code>curator-recipes</code>：包含各项高级功能的实现，如读写锁、互斥锁、队列等</li>
</ul>
</li>
</ol>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>Dubbo是一个高性能的RPC框架，主要提供三个核心功能：服务注册和发现、智能容错和负载均衡、面向接口远程调用</p>
<ol>
<li>注册中心：支持多种注册中心。服务提供者启动时，向注册中心注册自己的服务。消费者启动时，订阅自己需要的服务，一旦注册中心的服务列表变更，消费者能够感知。</li>
<li>服务提供者：在Dubbo中，服务提供者通过暴露服务的方式向注册中心注册自己的服务。</li>
<li>服务消费者：服务消费者通过注册中心订阅服务，并使用服务提供者暴露的服务。</li>
<li>监控中心：Dubbo提供了一个可视化的监控中心，用于展示服务的调用统计、方法调用次数、调用时间等。</li>
<li>容错机制：Dubbo提供了多种容错策略，如重试机制、容错切换、负载均衡等。</li>
<li>序列化机制：Dubbo支持多种序列化协议，如Hessian2、Dubbo、HTTP等。</li>
</ol>
<h4 id="暴露和引用"><a href="#暴露和引用" class="headerlink" title="暴露和引用"></a>暴露和引用</h4><ol>
<li>ProviderConfig：服务提供者配置类，可以用于配置服务的接口、服务实现类、协议等，还可以设置暴露服务所用的协议、权重、端口号等信息<ul>
<li>暴露过程中，首先需要解析配置，根据配置中的协议创建相应的协议实现</li>
<li>将协议绑定到指定的IP和端口上</li>
<li>将服务地址信息注册到注册中心，以供其他调用者查询</li>
<li>通知订阅者（监听器）服务地址信息的变化</li>
<li>调用者接收到订阅者的通知，得知服务地址信息变化</li>
<li>调用者通过网络层向提供者发起调用请求</li>
<li>提供者处理请求后，返回结果给调用者</li>
</ul>
</li>
<li>ConsumerConfig：服务消费者配置类，可以用于配置服务消费者所接口、协议等信息，还可以设置引用服务所用的协议、集群等信息<ul>
<li>解析配置，根据配置中的协议创建相应的协议实现</li>
<li>连接到指定的服务中心地址</li>
<li>查询注册中心，获取对应服务地址信息</li>
<li>返回服务地址信息给调用者</li>
<li>提供者处理调用请求，返回结果给调用者</li>
<li>调用者接收到结果，结束调用过程</li>
</ul>
</li>
</ol>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>用于管理服务提供者的注册与发现，使服务消费者能够动态地发现和访问服务提供者</p>
<ol>
<li>Zookeeper</li>
<li>Redis</li>
<li>Multicast</li>
<li>Nacos</li>
</ol>
<h4 id="服务提供者和服务消费者"><a href="#服务提供者和服务消费者" class="headerlink" title="服务提供者和服务消费者"></a>服务提供者和服务消费者</h4><ol>
<li>服务提供者：提供服务的主体，通常会暴露自己的服务接口，并通过某种协议提供服务<ul>
<li>向注册中心注册服务</li>
</ul>
</li>
<li>服务消费者：使用服务的主体，通常会引用提供者的服务接口，并通过某种协议调用服务<ul>
<li>服务消费者向注册中心订阅服务，获取服务提供者的地址信息，然后调用服务提供者的服务</li>
</ul>
</li>
</ol>
<h4 id="负载均衡、集群容错"><a href="#负载均衡、集群容错" class="headerlink" title="负载均衡、集群容错"></a>负载均衡、集群容错</h4><ol>
<li>负载均衡：服务消费者在调用服务提供者时从多个服务提供者中选择一个进行调用<ul>
<li>加权随机：根据权重随机调用</li>
<li>加权轮询：根据权重轮询调用</li>
<li>最少活跃：服务提供者收到的请求越少越不活跃，越不活跃的服务提供者收到的请求越少</li>
<li>一致性hash：根据请求参数调用</li>
</ul>
</li>
<li>集群容错：当服务提供者发生故障时，选择其他可用的节点<ul>
<li>Invoker：调用器，将消费者的请求转换成可执行的任务并执行</li>
<li>Cluster：集群容错模块，将多个Invoker封装成一个集群</li>
<li>Failover：失败自动切换容错策略，如果某次调用失败，会自动切换到下一个Invoker进行调用，直到成功为止</li>
<li>Failfast：快速失败容错策略，如果某次调用失败，会立即抛出异常</li>
<li>Failsafe：失败安全保护容错策略，如果某次调用失败，会记录下异常，但不会抛出异常</li>
<li>Failback：失败重试容错策略，如果某次调用失败，会在后台异步重试</li>
<li>Forking：并行调用容错策略，将请求并发调用多个Invoker，只要有一个Invoker成功返回结果，就立即返回</li>
<li>Broadcast：逐个调用容错策略，逐个调用多个Invoker</li>
</ul>
</li>
</ol>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ol>
<li>接口层：定义了服务提供者和服务消费者之间的通信接口</li>
<li>配置层：配置层的作用是通过配置文件或代码来配置Dubbo的各种参数，包括连接参数、超时时间、重试次数等等。Dubbo支持多种配置方式，包括XML配置、注解配置和属性配置</li>
<li>基础设施层：底层架构，包括RPC框架、网络通信、心跳检测、序列化和反序列化等实现细节</li>
</ol>
<h4 id="扩展机制"><a href="#扩展机制" class="headerlink" title="扩展机制"></a>扩展机制</h4><ol>
<li>SPI机制（Service Provider Interface）<ul>
<li>通过Java的ServiceLoader加载classpath下的自定义的接口实现类替换接口默认的实现</li>
<li>默认目录：MATE-INF&#x2F;services</li>
</ul>
</li>
<li>Adaptive机制<ul>
<li>对SPI机制的一种补充，可以根据不同的场景自动适配最合适的实现类</li>
<li>Adaptive机制通过动态生成的代理类来实现</li>
</ul>
</li>
<li>Extension机制：扩展机制的核心<ul>
<li>允许开发者自定义Dubbo的各种插件，包括Protocol、Transport和Serialization</li>
<li>通过@SPI和@Adaptive注解实现，通过实现指定接口和在注解中指定拓展名，来实现自定义插件的加载和使用</li>
</ul>
</li>
<li>通过SPI机制或者Extension机制实现自定义扩展</li>
<li>通过Filter接口和扩展机制实现自定义过滤器，可用于监控、鉴权、统计、日志等</li>
<li>通过LoadBalance接口和扩展机制实现自定义负载均衡</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/05/07/MySql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/07/MySql/" class="post-title-link" itemprop="url">MySql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-07 07:58:23" itemprop="dateCreated datePublished" datetime="2024-05-07T07:58:23+08:00">2024-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-29 02:46:49" itemprop="dateModified" datetime="2024-05-29T02:46:49+08:00">2024-05-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Mysql是一个开源、成熟的关系型数据库（RDB，Relational Database），主要用于存储持久化数据。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>MySql可以分为服务层和数据层，服务层负责处理查询解析、分析优化、缓存和客户端交互，数据层负责数据存储和读取。</p>
<ol>
<li>连接器：管理客户端连接，用于身份认证和权限验证</li>
<li>查询缓存：执行查询语句时，优先从缓存中检索，如果检索到数据则直接返回否则去存储引擎中查询数据并缓存，MySql8后移除</li>
<li>分析器：解析SQL语句的词法和语义并且预处理</li>
<li>优化器：按照MySql认为的最优方案执行SQL</li>
<li>执行器：执行语句，然后从存储引擎返回数据，执行语句之前会先判断是否有权限，如果没有权限的话，就会报错</li>
<li>存储引擎：负责数据的存储和读取，插件式架构，主要插件有InnoDB和MyISAM等类型</li>
<li>日志：binlog，记录更新语句的日志，用于备份和同步</li>
</ol>
<h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><ol>
<li>查询：权限校验-&gt;查询缓存-&gt;分析器-&gt;优化器-&gt;权限校验-&gt;执行器-&gt;存储引擎</li>
<li>更新：权限校验-&gt;分析器-&gt;执行器-&gt;存储引擎（InnoDB）-&gt;redo log（prepare状态）-&gt;binlog-&gt;redo log（commit状态）-&gt;清除查询缓存</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构，底层数据结构存在很多种类型，常见的索引结构有：Hash表、B树、B+树、红黑树。</p>
<ol>
<li>优点：<ul>
<li>使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少磁盘IO次数，这也是创建索引的最主要的原因</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
<li>数据量比较大时，索引查询比全表扫描快</li>
</ul>
</li>
<li>缺点：<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率</li>
<li>索引需要使用物理文件存储，会耗费一定磁盘空间</li>
<li>数据量比较小时，索引查询性能提升不明显</li>
</ul>
</li>
</ol>
<p>在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作为索引结构。</p>
<ol>
<li>Hash表：键值对集合，查询时间复杂度O(1)<ul>
<li>优点：通过哈希算法计算出key的哈希值，即索引&#x2F;index</li>
<li>缺点<ul>
<li>哈希冲突：不同的key可能计算出相同的哈希值，需要用链地址法将相同哈希值的value保存在链表中</li>
<li>不支持排序和范围查询</li>
</ul>
</li>
</ul>
</li>
<li>二叉查找树（BST，Binary Search Tree）：左子节点小于父节点，右子节点大于父节点，查询时间复杂度O(logN)<ul>
<li>优点：基于二分查找查询，支持排序和范围查询</li>
<li>缺点：平衡程度依赖于插入顺序，极端情况会退化成斜树（线性链表），导致时间复杂度变成O（N）</li>
</ul>
</li>
<li>AVL树：高度平衡二叉树，保证了任何节点的左右子树高度差不超过1，时间复杂度O(logN)<ul>
<li>优点：通过旋转操作保证了二叉树的严格平衡</li>
<li>缺点：<ul>
<li>插入、删除时需要频繁旋转</li>
<li>一个节点只能保存一个数据，因此磁盘IO次数会比较多</li>
</ul>
</li>
</ul>
</li>
<li>红黑树：自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持大致平衡状态，查询时间复杂度O(logN)<ul>
<li>优点：不追求严格平衡，插入和删除节点时只需进行O(1)次数的旋转和变色操作</li>
<li>缺点：<ul>
<li>大致平衡状态可能会导致树的高度比较高，进而导致一些数据的磁盘IO次数比较多</li>
<li>一个节点只能保存一个数据，因此磁盘IO次数会比较多</li>
</ul>
</li>
</ul>
</li>
<li>B树：多路平衡查找树，时间复杂度O(logN)<ul>
<li>优点：一个节点可以保存多个数据，降低树的高度</li>
<li>缺点：节点既存放key也存放value，可能会导致不必要的磁盘IO</li>
</ul>
</li>
<li>B+树：B树的变种<ul>
<li>一个节点可以保存多个数据，降低树的高度</li>
<li>叶子节点保存key和value，非叶子节点只保存key</li>
<li>叶子节点通过双向链表指向相邻的叶子节点</li>
<li>具备更少的磁盘IO次数、更稳定的查询效率和更适于范围查询</li>
</ul>
</li>
</ol>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ol>
<li>按照数据结构维度划分<ul>
<li>B树索引：MySQL里默认和最常用的索引类型，只有叶子节点存储value，非叶子节点只有指针和key</li>
<li>哈希索引：类似键值对的形式，一次即可定位</li>
<li>R树索引：一般不会使用，仅支持geometry数据类型，优势在于范围查找，效率较低一般不会使用，通常使用搜索引擎如ElasticSearch代替</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有CHAR、VARCHAR、TEXT列上可以创建全文索引。效率较低一般不会使用，通常使用搜索引擎如ElasticSearch代替</li>
</ul>
</li>
<li>按照底层存储方式角度划分<ul>
<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB中的主键索引就属于聚簇索引<ul>
<li>B+树上所有非叶子节点存储索引和页内存地址，叶子节点存储索引和数据，因此索引数据（主键）最好是有序的或者整数，并且最好不轻易修改</li>
</ul>
</li>
<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，InnoDB的二级索引（辅助索引）就属于非聚簇索引，MyISAM不管主键还是非主键使用的都是非聚簇索引<ul>
<li>B+树上所有非叶子节点存储索引和页内存地址，叶子节点存储索引和数据指针（主键数据或数据内存地址），因此可能需要二次查询（回表）查出真正的数据值</li>
</ul>
</li>
</ul>
</li>
<li>按照应用维度划分<ul>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>覆盖索引：一个索引包含&#x2F;覆盖所有需要查询的字段的值，因此不需要额外再查询</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有char、varchar、text列上可以创建全文索引。效率较低一般不会使用，通常使用搜索引擎如ElasticSearch代替</li>
</ul>
</li>
<li>主键索引：数据表的主键就是使用的主键索引，主键不能重复不能为null。InnoDB中如果没有主键，会选择不为null的唯一索引作为主键索引，如果再没有，就会自动创建一个6Byte的自增主键</li>
<li>二级索引：普通索引、唯一索引、前缀索引都属于二级索引<ul>
<li>普通索引：一张表运行创建多个普通索引，并允许数据重复和null，可以快速查询数据</li>
<li>唯一索引：一张表运行创建多个唯一索引，并允许数据为null但是不能重复，可以快速查询数据但是主要是为了限制数据不能重复</li>
<li>前缀索引：只适用于字符串类型的数据，即对字符串的前缀字符创建索引，比普通索引建立的数据量小</li>
<li>全文索引：只适用于char、varchar、text文本类型的数据</li>
</ul>
</li>
<li>联合索引：使用表中多个字段创建的索引，包含这些列的查询都会走联合索引<ul>
<li>最左前缀匹配原则：联合索引(c1,c2,c3)相当于(c1)、(c1,c2)、(c1,c2,c3)三个普通索引，因此区分度高的字段优先排在左边从而过滤更多数据</li>
</ul>
</li>
<li>索引下推：索引下推（ICP，Index Condition PushDown）是MySQL5.6版本中提供的一项索引优化功能<ul>
<li>允许存储引擎在索引遍历过程中，执行部分where字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率</li>
</ul>
</li>
</ol>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ol>
<li>适合创建索引的字段<ul>
<li>不为null的字段：索引字段的数据应该尽量不为null<ul>
<li>对于数据为null的字段，数据库较难优化</li>
<li>如果字段频繁被查询，但又避免不了为null，可以使用0,1,true,false这样语义较为清晰的短值或短字符作为替代</li>
</ul>
</li>
<li>频繁查询的字段和作为条件查询的字段</li>
<li>频繁需要排序的字段：索引已经排序</li>
<li>涉及到多表关系且频繁使用的字段：提高多表连接查询的效率</li>
</ul>
</li>
<li>不适合创建索引的字段<ul>
<li>频繁更新的字段：会增加维护索引的压力</li>
</ul>
</li>
<li>限制每张表的索引数量<ul>
<li>需要维护多个索引，增加了更新操作的执行时间</li>
<li>可能会增加SQL优化器的执行时间</li>
</ul>
</li>
<li>使用联合索引代替多个单列普通索引，避免索引冗余</li>
<li>使用前缀索引代替字符串类型的单列普通索引</li>
<li>避免索引失效（失效原因）<ul>
<li>查询条件的范围过大（where between and、in、not in），可能会使索引失效而走全表扫描，更会增加数据传输和处理时间的性能浪费</li>
<li>创建了联合索引但是查询条件不符合最左前缀匹配原则</li>
<li>在索引列上进行计算、类型转换、内置函数等操作</li>
<li>like条件查询以<code>%</code>开头</li>
<li>or条件查询所在列至少有一个没有索引</li>
</ul>
</li>
</ol>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySql的存储引擎是插件式架构，内置了多种存储引擎，并且可以通过MySql定义的存储引擎标准接口来实现第三方存储引擎。</p>
<ol>
<li>MyISAM：MySql5.5之前默认的存储引擎，使用B+树作为索引结构<ul>
<li>具有全文检索、压缩、空间函数、数据缓存等特性，仅支持表级锁</li>
<li>不支持事务、外键、崩溃恢复、MVCC、读写并发，索引文件和数据文件分离</li>
<li>非聚簇索引：B+树的叶子节点的data域存放的是数据记录的地址，检索时先从B+树找到数据地址再读取具体的数据值</li>
</ul>
</li>
<li>InnoDB：MySql5.5之后默认的存储引擎，使用B+树作为索引结构<ul>
<li>支持事务、外键、崩溃恢复、MVCC、读写并发、表级锁、行级锁、间隙锁</li>
<li>聚簇索引：数据文件本身就是索引文件，索引的Key就是数据表的主键，其他索引都是辅助索引并且data域存放的是主键的值</li>
</ul>
</li>
<li>对比：InnoDB的性能比MyISAM更强大<ul>
<li>InnoDB支持行级别的锁粒度，MyISAM不支持，只支持表级别的锁粒度</li>
<li>MyISAM不提供事务支持，InnoDB提供事务支持，实现了SQL标准定义了四种隔离级别</li>
<li>MyISAM不支持外键，而InnoDB支持</li>
<li>MyISAM不支持MVCC，而InnoDB支持</li>
<li>虽然MyISAM引擎和InnoDB引擎都是使用B+Tree作为索引结构，但是两者的实现方式不一样</li>
<li>MyISAM不支持数据库异常崩溃后的安全恢复，而InnoDB支持</li>
<li>MyISAM使用键缓存仅缓存了索引页而不缓存数据页，InnoDB使用缓冲池缓存了数据页和索引页</li>
</ul>
</li>
</ol>
<h2 id="InnoDB架构"><a href="#InnoDB架构" class="headerlink" title="InnoDB架构"></a>InnoDB架构</h2><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><ol>
<li><code>Buffer Pool</code>：缓冲池，链表结构，内部数据包括<code>Page Cache</code>、<code>Change Buffer</code>、<code>Data Dictionary Cache</code><ul>
<li>InnoDB中数据管理的最小单位是页，默认每页16KB，包含了若干行数据</li>
<li>为了提供缓存管理效率，InnoDB的缓冲池通过一个页链表实现，很少访问的页通过LRU算法淘汰</li>
<li>页链表分为两个部分<ul>
<li><code>new sublist</code>：<code>old sublist</code>中的页被访问到会移动到<code>new sublist</code>的头部</li>
<li><code>old sublist</code>：新读取的页会加入到<code>old sublist</code>的头部</li>
</ul>
</li>
<li>页读取方式<ul>
<li>内存读取：读取已经被MySql加载到内存的页</li>
<li>随机IO：从磁盘中查找页并读取</li>
<li>顺序读取：从磁盘中查找页并按照顺序批量读取</li>
</ul>
</li>
</ul>
</li>
<li><code>Change Buffer</code>：变更缓冲区，缓冲池的内部结构，使用B+树实现，用于缓存除唯一索引外的二级索引页的更改操作<ul>
<li>如果二级索引页已经在缓冲区，则直接修改</li>
<li>如果二级索引页不在缓冲区，则先将修改保存到变更缓冲区，当真正二级索引页被读取到缓冲区时再合并修改内容</li>
</ul>
</li>
<li><code>Adaptive Hash Index</code>：自适应哈希索引，哈希结构，由InnoDB自动维护，用于提高索引查询速度<ul>
<li>AHI查询的时间复杂度为O(1)，比B+树O(logN)快</li>
<li>InnoDB通过观察索引页上的查询次数，如果超过阈值则认为建立AHI比直接查询B+树的效率高，就会自动建立AHI</li>
<li>AHI的key是查询条件，value是索引在B+树上的位置</li>
<li>相同查询条件的AHI会自动合并，即自适应</li>
</ul>
</li>
<li><code>Log Buffer</code>：日志缓冲区，用于缓存<code>redo log</code>，默认16M<ul>
<li>日志先行策略：数据先在<code>Buffer Pool</code>中修改完成并记录到<code>Log Buffer</code>的<code>redo log</code>，随后立即响应客户端事务提交成功，<code>redo log</code>再通过顺序IO提交事务持久化到磁盘</li>
<li><code>redo log</code>：表空间号+数据页号+偏移量+修改数据长度+具体修改的数据</li>
<li><code>innodb_flush_log_at_trx_commit</code>：用于控制<code>Log Buffer</code>的<code>redo log</code>如何刷新到磁盘<ul>
<li>0：每秒一次，写入内核缓冲区并刷新到磁盘</li>
<li>1：默认，每次提交事务时写入内核缓冲区并刷新到磁盘</li>
<li>2：每次提交事务时写入内核缓冲区，每秒一次刷新到磁盘</li>
</ul>
</li>
<li><code>Log Buffer</code>满、定期执行<code>Checkpoint</code>、后台刷新线程一秒周期执行、正常关闭Mysql都会刷盘</li>
</ul>
</li>
<li><code>Operating System Cache</code>：操作系统内核缓冲区，默认使用操作系统的<code>fsync()</code>方法将内核缓冲区的内存文件刷新到磁盘文件</li>
</ol>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>InnoDB的磁盘结构主要分为<code>tablespace</code>和<code>redo log</code>。</p>
<p>表空间是一个逻辑概念，它可以同一管理空间中的所有数据文件，一个数据库可以有多个表空间，但一个表空间只能属于一个数据库。</p>
<ol>
<li><code>system tablespace</code>：系统表空间，数据存放在<code>ibdata1</code>文件中，包含内容有数据字典信息、双写缓冲区、变更缓冲区、系统表空间内置表的数据和索引<ul>
<li>数据字典信息：InnoDb内置的一些内部系统表记录的元数据，用于客户端插入语句的校验、数据和索引的定位（校验表、检索表空间、段、区、页）</li>
<li>双写缓冲区：<code>Log Buffer</code>的<code>redo log</code>刷新到磁盘时无法保证原子写入表空间文件（页16KB&gt;<br>磁盘扇区512Byte），如果在写入过程中操作系统出现问题，那可能只写入了部分数据，因此在数据写入表空间文件前会先写入双写缓冲区，如果双写缓存区写入出错则直接丢弃<code>Log Buffer</code>的<code>redo log</code><br>，如果表空间文件写入出错则可以从双写缓冲区恢复</li>
</ul>
</li>
<li><code>general tablespace</code>：常规表空间，通过<code>create tablespace</code>创建，多个表可以共享一个常规表空间，各个表的数据和索引分散存储在<code>.idb</code>文件中</li>
<li><code>temporary tablespace</code>：临时表空间，非压缩的临时表的存储空间<ul>
<li>会话临时表空间：由同一个session的请求创建，最多两个，一个是客户端创建的，一个是优化器创建的</li>
<li>全局临时表空间：默认是数据目录下的<code>ibtmp1</code>文件，被所有临时表共享，保存了<code>undo log</code>，用于事务回滚</li>
</ul>
</li>
<li><code>file-per-table tablespace</code>：独立空间表，每个表单独拥有的表空间，即每个表可以有单独的<code>.ibd</code>数据文件</li>
<li><code>undo tablespace</code>：Undo表空间，存放<code>undo log</code>，用于事务回滚，MySql初始化时会创建两个默认的（undo_001和undo_002），通过<code>innodb_undo_directory</code>指定位置<ul>
<li>如果不指定，则存放在数据字典中（innodb_undo_001和innodb_undo_002）</li>
<li><code>undo log</code>在事务执行过程中就会产生，事务提交后才会持久化，如果事务回滚了则<code>undo log</code>也会删除</li>
<li>可以实现MVCC（多版本并发控制）</li>
</ul>
</li>
<li><code>redo log</code>：存储<code>Log Buffer</code>刷到磁盘的数据，Mysql8.0.30前由<code>innodb_log_file_size</code>和<code>innodb_log_file_in_group</code><br>配置文件大小和数量；之后固定32个，由<code>innodb_redo_log_capacity</code>配置总容量<ul>
<li><code>redo log</code>：<code>log blocks</code> &#x3D; 表空间号+数据页号+偏移量+修改数据长度+具体修改的数据</li>
<li><code>log blocks</code>：512Byte的数据块，日志记录&#x2F;实际数据（496）&#x3D; 数据块（512）- 块头（12）-块尾（4）</li>
</ul>
</li>
</ol>
<h4 id="表空间结构"><a href="#表空间结构" class="headerlink" title="表空间结构"></a>表空间结构</h4><ol>
<li>表文件：<ul>
<li><code>.opt文件</code>：保存数据库的字符集和校验方法</li>
<li><code>.frm文件</code>：保存表的数据字典信息，这是历史原因遗留的备份文件，InnoDB的数据字典信息主要是存储在系统表空间的<code>ibdata1</code>文件中</li>
<li><code>.ibd文件</code>：保存表的数据和索引，表空间对应的文件，使用限制：每个表最多64个二级索引、每行数据不能超过65535、联合索引不能超过16个字段等</li>
</ul>
</li>
<li>文件结构：<ul>
<li><code>tablespace</code>：表空间，由一个或多个段组成</li>
<li><code>segment</code>：段，段是磁盘上以区为单位执行空间分配和回收的申请者，是一个逻辑概念，用来管理物理文件，一个段最多包含256个区（256M大小）<ul>
<li>为了提高范围查询的效率，段又分为数据段、索引段、回滚段等，</li>
<li>数据段是为了保持叶子节点在磁盘上的连续，可以在范围查询时实现顺序I&#x2F;O操作，因为这些叶子节点包含实际的表数据</li>
<li>索引段就是非叶子结点部分</li>
<li>回滚段用于数据的回滚和多版本控制</li>
</ul>
</li>
<li><code>extent</code>：区，由64个连续的页组成的空间，默认1MB<ul>
<li>让逻辑相邻的页在物理上也相邻，在范围查询时可以顺序IO</li>
<li>为了保证区中页的连续性，数据量比较大时InnoDB会一次从磁盘申请多个物理连续的区</li>
</ul>
</li>
<li><code>page</code>：页，是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，存储了与数据库相关的所有内容<ul>
<li>所有页的结构都是一样的，分为文件头（前38个字节）、页数据和文件尾（后8个字节）</li>
</ul>
</li>
<li><code>row</code>：数据行，数据库表的一行完整数据，多行数据组成页数据</li>
</ul>
</li>
<li>Page页分类<ul>
<li><code>file_space_header/fsh_hdr</code>页：第0页，用于存储区的元信息，里面的256个区描述符（extent descriptors，XDES）存储了256个区的元信息，包括区的使用情况和区内页的使用情况</li>
<li><code>ibuf_bitmap</code>页：第1页，用于记录<code>change buffer</code>的使用情况</li>
<li><code>inode</code>页：第2页，用于记录文件段（FSEG）的信息，每页有85个inode，每个inode占用192字节，记录了段id、段内区信息、区内碎片页信息<ul>
<li>文件段ID</li>
<li>段内区的信息：记录了free（完全空闲）、not_full（部分空闲）、full（没有空闲）三种类型的区的信息（List Base Node，包含链表长度、头尾页号和偏移量的结构体）</li>
<li>区内碎片页信息：每个区可以有32个碎片页，InnoDB在段内以区为单位分配磁盘空间，如果数据量比较少，区内页使用率比较少，就会优先使用碎片页从而节省空间，而不是又申请区，当区内碎片页数量超过32时才会申请新的区</li>
</ul>
</li>
<li><code>index</code>页：第3页之后，索引页的叶子结点的data就是数据，如聚簇索引存储的行数据，非聚簇索引存储的主键值</li>
</ul>
</li>
<li>Page页结构<ul>
<li><code>File header</code>：文件头，36字节，主要保存了上下两页的指针和本页的状态信息</li>
<li><code>Page header</code>：页面头，56字节，记录数据页的状态信息</li>
<li><code>Infimum</code>：虚拟的一行记录，记录本页中比主键小的值</li>
<li><code>Supremum Records</code>：虚拟的一行记录，记录本页中比主键大的值</li>
<li><code>User Records</code>：实际存储的行数据</li>
<li><code>Free Space</code>：空闲空间</li>
<li><code>Page Directory</code>：页目录</li>
<li><code>File Tailer</code>：8字节，用于检查页是否已完整写入磁盘</li>
</ul>
</li>
</ol>
<h2 id="Mysql日志"><a href="#Mysql日志" class="headerlink" title="Mysql日志"></a>Mysql日志</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ol>
<li>重做日志，基于InnoDB引擎，实现Mysql崩溃恢复，保证数据持久性和完整性<ul>
<li>客户端CURD数据时InnoDB优先从<code>Buffer Pool</code>检查，没有则会把数据所在页加载到<code>Buffer Pool</code>中</li>
<li>在<code>Buffer Pool</code>更改数据时会把数据页的更改记录更新到<code>Log Buffer</code>，随后响应客户端</li>
<li><code>Log Buffer</code>先刷盘到磁盘的双写缓冲区和<code>redo log</code>文件，再刷盘到表空间文件</li>
</ul>
</li>
<li>文件组：按照顺序环形写入<ul>
<li><code>write pos</code>：当前记录的位置，写入数据，写完后移</li>
<li><code>check point</code>：恢复数据的位置，恢复完成清除数据并后移</li>
<li>当<code>write pos</code>&#x3D;<code>check point</code>时，说明日志文件组满了，需要将<code>check point</code>后移</li>
</ul>
</li>
</ol>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><ol>
<li>二进制归档日志，属于Mysql的server层的逻辑日志，按照顺序记录了SQL语句的原始逻辑，主要用于数据备份、集群同步</li>
<li>格式（<code>binlog_format</code>）：<code>update table1 set time = now() where id = 1</code><ul>
<li><code>statement</code>：记录SQL语句的原文：<code>use database1;update table1 set time = now() where id = 1</code></li>
<li><code>row</code>：记录SQL语句的event引用，将时间函数变成具体的时间，需要通过binlog工具解析：<code>update database1.table1 set time = 1111 where @1 = 1 @2 = 1110</code></li>
<li><code>mixed</code>：<code>statement</code>和<code>row</code>混合，MySql判断SQL语句可能会引起数据不一致时使用<code>row</code>，否则使用<code>statement</code></li>
</ul>
</li>
<li>写入时机：事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到文件系统缓存<code>page cache</code>，最后<code>fsync</code>刷盘到<code>binlog</code>文件中<ul>
<li><code>binlog_cache_size</code>：每个刷盘线程使用的内存大小，超过会暂存到磁盘</li>
<li><code>sync_binlog</code>：<ul>
<li>0：每次提交事务只写入<code>page cache</code>，由系统判断<code>fsync</code>时机</li>
<li>1：每次提交事务先写入<code>page cache</code>，再<code>fsync</code></li>
<li>n(n &gt; 1)：每次提交事务先写入<code>page cache</code>，累计n次事务后再<code>fsync</code></li>
</ul>
</li>
</ul>
</li>
<li>恢复数据：两阶段提交<ul>
<li>redo log（prepare状态）-&gt;bin log-&gt;redo log（commit状态）</li>
<li>bin log刷盘出错，恢复数据时发现有redo log（prepare状态）、没有bin log则回滚事务</li>
<li>redo log（commit状态）出错，恢复数据时发现有redo log（prepare状态）、有bin log则提交事务</li>
</ul>
</li>
</ol>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><ol>
<li>回滚日志，基于InnoDB引擎，用于事务回滚，保证事务原子性，可以实现MVCC</li>
<li>属于逻辑日志<ul>
<li>事务执行insert语句，undo log就会记录delete语句，事务提交后就会清除undo log</li>
<li>事务执行update&#x2F;delete语句，undo log就会记录update&#x2F;insert语句，事务提交后不会立即清除undo log，而是保存在history list中，由后台线程purge进行清除</li>
</ul>
</li>
<li>并发事务的回滚：undo log 是采用段的方式来记录<ul>
<li>每个undo操作在记录的时候占用一个undo log segment</li>
<li>undo log segment包含在rollback segment（回滚段）中</li>
<li>事务开始时，需要为其分配一个rollback segment，每个rollback segment有1024个undo log segment，这有助于管理多个并发事务的回滚需求</li>
<li>rollback segment header位于rollback segment的第一页，负责管理rollback segment</li>
<li>history list是rollback segment header的一部分，用于保存已经提交但为清除的事务的undo log</li>
<li>purge线程从history list清除undo log</li>
</ul>
</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Mysql的InnoDB引擎实现了事务和SQL标准定义的四个隔离级别。</p>
<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>InnoDB通过<code>Buffer Pool</code>、<code>Log Buffer</code>、<code>redo log</code>、<code>undo log</code>来实现事务。</p>
<ol>
<li>InnoDB执行更新语句，先根据条件找到数据所在的页，并缓存到<code>Buffer Pool</code>中</li>
<li>执行更新语句，修改<code>Buffer Pool</code>中的数据，也就是内存中的数据</li>
<li>针对更新语句生成一个<code>RedoLog</code>对象，并存入<code>Log Buffer</code>中，用于提交事务</li>
<li>针对更新语句生成<code>undo log</code>日志，用于事务回滚</li>
<li>如果事务提交，那么则把<code>RedoLog</code>对象进行持久化，通过双写缓冲区将<code>Buffer Pool</code>中所修改的数据页持久化到磁盘中</li>
<li>如果事务回滚，则利用<code>undo log</code>日志进行回滚</li>
</ol>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务具有四种特性：原子性、一致性、隔离型、持久性，即ACID特性</p>
<ol>
<li>原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。</li>
<li>一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。</li>
<li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。</li>
<li>持久性（Durability）：一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</li>
</ol>
<h3 id="隔离性问题"><a href="#隔离性问题" class="headerlink" title="隔离性问题"></a>隔离性问题</h3><p>事务的隔离性定义了并发事务互不干扰，但在不同的隔离级别下，仍有可能出现一些问题：</p>
<ol>
<li>脏读：事务A读取事务B未提交的数据后，事务B回滚数据，导致事务A读到的数据无效。</li>
<li>不可重复读：事务A多次查询同一数据，在查询间隔内事务B修改了数据，导致事务A得到了不同结果，</li>
<li>幻读：事务A多次范围查询同一组数据集，在查询间隔内事务B修改了数据集，导致事务A得到的数据集不一样。如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。</li>
</ol>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol>
<li>读未提交：最低的隔离级别<ul>
<li>当前事务可以看到其他事务未提交的修改</li>
<li>可能出现脏读、不可重复读和幻读</li>
</ul>
</li>
<li>读已提交：Oracle默认<ul>
<li>当前事务可以看到其他事务已提交的修改</li>
<li>可能出现不可重复读和幻读</li>
</ul>
</li>
<li>可重复读：Mysql默认<ul>
<li>一个事务多次查询同一数据能得到一致的结果，其他事务对同一数据的修改不会造成影响</li>
<li>可能出现幻读</li>
</ul>
</li>
<li>串行化：最高的隔离级别<ul>
<li>所有事务按照次序依次执行</li>
</ul>
</li>
</ol>
<p>不同的事务隔离级别提供了不同程度的隔离策略，以满足不同应用场景对于一致性和性能的需求，在选择事务隔离级别时，需要在数据一致性和系统性能之间进行权衡。</p>
<h2 id="MySql锁机制"><a href="#MySql锁机制" class="headerlink" title="MySql锁机制"></a>MySql锁机制</h2><p>MySql的锁机制可以分为三种</p>
<ol>
<li>表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM、InnoDB）</li>
<li>行级锁：开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB）</li>
<li>页级锁：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般（BDB引擎）</li>
</ol>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ol>
<li>MyISAM存储引擎仅支持表级锁：表独占锁&#x2F;写锁、表共享锁&#x2F;读锁<ul>
<li>同一张表的读锁不会阻塞读锁但会阻塞写锁</li>
<li>同一张表的写锁会阻塞读锁和写锁。</li>
</ul>
</li>
</ol>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB存储引擎默认的事务隔离级别是可重复读，在这种隔离级别下，InnoDB支持七种锁。</p>
<ol>
<li>自增锁（表级锁）<ul>
<li>自增锁（AUTO-INC Locking）是指在并发插入新行并且涉及自增列时，保证自增列的值是唯一且连续的机制</li>
<li>自增锁的实现方式是，在分配下一个自增值之前，MySQL会获取一个表级别的锁，确保在分配新值的过程中，该值是唯一并且连续分配的</li>
</ul>
</li>
<li>共享锁&#x2F;排他锁（表级锁&#x2F;行级锁）<ul>
<li>共享锁（S）：允许多个事务去读数据，阻止其他事务取得相同数据集的排他写锁</li>
<li>排他锁（Ｘ）：允许获得排他锁的事务更新数据，阻止其他事务取得相同的数据集的共享读锁和排他写锁</li>
<li>对于update、delete和insert语句，InnoDB会自动给涉及到的数据集加排他锁；对于普通的select语句，InnoDB不会加任何锁</li>
<li>事务可以通过以下语句显式地给数据集加共享锁或排他锁<ul>
<li>共享锁：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</li>
<li>排他锁：SELECT * FROM table_name WHERE … FOR UPDATE</li>
</ul>
</li>
<li>InnoDB行锁是通过索引上的索引项来实现的，即只有通过索引条件检索数据时，InnoDB才会使用行级锁，否则InnoDB将使用表级锁</li>
</ul>
</li>
<li>意向共享锁&#x2F;意向排他锁（表级锁）<ul>
<li>意向共享锁（IS）：事务打算给一个数据行加共享锁前，必须先取得该表的意向共享锁</li>
<li>意向排他锁（IX）：事务打算给一个数据行加排他锁前，必须先取得该表的意向排他锁</li>
<li>意向锁是InnoDB自动加的，不需要客户端干预，由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行</li>
<li>但意向锁会与行级锁互斥，仅意向共享锁与共享锁兼容</li>
</ul>
</li>
<li>插入意向锁（间隙锁的一种）<ul>
<li>支持插入并发</li>
</ul>
</li>
<li>记录锁：锁定索引记录，行级锁<ul>
<li><code>select * from table1 where id = 1 for update</code>，锁定id&#x3D;1的索引，阻止其他事务插入、更新、删除id&#x3D;1这一行</li>
<li><code>select * from table1 where id = 1</code>，并没有加锁，事务使用快照读，非事务使用当前读</li>
<li>InnoDB默认的事务隔离级别是可重复读，非事务情况下会有不可重复读问题，事务情况下不会有不可重复读问题，事务加记录锁情况下不会有不可重复读问题</li>
<li>如果把隔离级别降级成读已提交&#x2F;读未提交，间隙锁就会失效</li>
</ul>
</li>
<li>间隙锁：锁定索引范围区间内的记录，行级锁<ul>
<li><code>select * from table1 where id &gt; 7 and id &lt; 9 for update</code>，锁定id&#x3D;8到10之间的索引，阻止其他事务插入、更新、删除id&#x3D;7、8、9这一行</li>
<li><code>select * from table1 where id &gt; 7 and id &lt; 9</code>，并没有加锁，事务使用快照读，非事务使用当前读</li>
<li>InnoDB默认可重复读，非实物情况下会出现幻读，事务情况下不会出现幻读，事务加间隙锁情况下不会出现幻读</li>
<li>如果把隔离级别降级成读已提交&#x2F;读未提交，间隙锁就会失效</li>
</ul>
</li>
<li>临键锁：记录锁与间隙锁的组合，锁定索引本身及之前或之后区间内的记录，行级锁<ul>
<li><code>select * from table1 where id &lt; 3 for update</code>，锁定id&lt;&#x3D;3的索引，阻止其他事务插入、更新、删除id&#x3D;1、2、3这三行</li>
<li><code>select * from table1 where id &lt; 3</code>，并没有加锁，事务使用快照读，非事务使用当前读</li>
<li>InnoDB默认可重复读，非实物情况下会出现幻读，事务情况下不会出现幻读，事务加临键锁情况下不会出现幻读</li>
<li>如果把隔离级别降级成读已提交&#x2F;读未提交，临键锁就会失效</li>
</ul>
</li>
</ol>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>Mysql</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>MVCC是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p>
<ol>
<li>读操作（SELECT）：当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改<ul>
<li>对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取</li>
<li>如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据</li>
<li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作</li>
</ul>
</li>
<li>写操作（INSERT、UPDATE、DELETE）：当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库<ul>
<li>对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本</li>
<li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据</li>
<li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响</li>
</ul>
</li>
<li>事务提交和回滚<ul>
<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见</li>
<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见</li>
</ul>
</li>
<li>版本的回收：为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间</li>
</ol>
<p>MVCC通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ol>
<li>undo log日志版本链：更改操作的事务完成后，InnoDB会保留修改前的数据的undo回滚日志，并用两个隐藏属性把回滚日志串联起来<ul>
<li>trx_id：事务id，开启事务且在执行第一条SQL执行前分配，顺序按照事务的启动顺序分配</li>
<li>roll_pointer：回滚指针，指向上一条旧的日志记录，位于<code>rollback tablespace-&gt;rollback segment-&gt;rollback segment header-&gt;history list</code></li>
</ul>
</li>
<li>read view：开启事务并执行查询操作时会生成当前事务的一致性视图，包括当前未提交事务id集合、集合中最小事务id、预分配事务id（当前最大事务id+1）、当前事务id–&gt;m_ids、min_id、max_id、trx_id<ul>
<li>在执行查询时生成，由所有未提交事务id数组（min_id）和已提交的最大事务id（max_id）组成，事务里的任何sql查询结果，需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果<ul>
<li>可重复读隔离级别：生成后就不会再变化</li>
<li>读可提交隔离级别：每次执行查询操作都会重新生成</li>
</ul>
</li>
</ul>
</li>
<li>版本链对比规则<ul>
<li>如果trx_id&lt;min_id，表示这个版本是已提交事务生成的，即数据可见</li>
<li>如果trx_id&gt;max_id，表示这个版本是未开启的事务生成的，即数据不可见</li>
<li>如果min_id&lt;&#x3D;trx_id&lt;&#x3D;max_id<ul>
<li>如果trx_id在未提交事务数组中，表示这个版本是未提交事务生成的，即数据不可见</li>
<li>如果trx_id不在未提交事务数组中，表示这个版本是已提交事务生成的，即数据可见</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><ol>
<li>MySql慢查询值查询语句中执行时间超过指定阈值的语句，MySql会将这些查询语句记录在指定位置<ul>
<li><code>slow_query_log</code>：慢查询日志，0&#x2F;OFF关闭、1&#x2F;ON开启</li>
<li><code>slow_query_log_file</code>：日志文件位置</li>
<li><code>long_query_time</code>：超时阈值，单位秒</li>
<li><code>log_queries_not_using_indexes</code>：未使用索引的查询也记录</li>
<li><code>log_output</code>：记录形式（FILE&#x2F;TABLE），记录到指定文件或mysql.slow_log表</li>
</ul>
</li>
<li>分析<ul>
<li><code>mysqldumpslow -s at mysql-slow.log | more</code>，按顺序列出慢查询日志文件中所有查询语句</li>
</ul>
</li>
<li>原因：可以通过执行计划具体分析具体解决<ul>
<li>主机服务器问题：内存不足、带宽不足、磁盘IO吞吐量</li>
<li>查询语句问题：数据量太大、查询语句未走索引</li>
<li>应用程序问题：出现锁等待、死锁</li>
</ul>
</li>
<li>解决方案：<ul>
<li>增加主机服务器配置、集群、分库分表</li>
<li>优化查询语句、建立合适索引</li>
<li>优化应用程序代码，不要出现死锁</li>
</ul>
</li>
</ol>
<h2 id="设计规范-优化"><a href="#设计规范-优化" class="headerlink" title="设计规范&#x2F;优化"></a>设计规范&#x2F;优化</h2><ol>
<li>分析需求，划分功能模块，设计E-R图和数据库表结构<ul>
<li>可以不严格遵化三范式，保证第一范式数据库表字段属性尽量不可再拆分即可，没必要严格保证外键，可以有部分冗余</li>
</ul>
</li>
<li>编写代码，创建索引<ul>
<li>主键索引：数值类型并且自增，如雪花算法</li>
<li>唯一索引：保证字段可以为null但是不能重复</li>
<li>联合索引：代替多个普通索引，检索索引数量</li>
<li>多条件查询语句尽量复合索引覆盖和索引下推</li>
<li>代码层面优化减少不必要的索引，如逻辑删除使用回收站</li>
<li>代码层面分页查询优化：避免查询大量数据和不必要字段、使用主键索引自查询避免limit偏移量太大</li>
</ul>
</li>
<li>压力测试，优化SQL和索引<ul>
<li>使用存储过程批量插入大量数据</li>
<li>并发测试验证应用程序和数据库的吞吐量</li>
</ul>
</li>
<li>常规测试，优化功能<ul>
<li>边界测试验证应用程序和数据库的非正常数据的处理能力</li>
</ul>
</li>
<li>慢查询日志<ul>
<li>分析查询SQL解决查询慢的问题</li>
</ul>
</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h3><p>CAP原则：一致性、可用性、分区容错性只能满足其二</p>
<p>BASE理论：牺牲一致性，强一致性、弱一致性、最终一致性</p>
<p>主从同步基于Mysql的binlog，分库分表、读写分离依赖于第三方组件（Sharding JDBC、MyCat、mysql proxy）</p>
<ol>
<li>一主一从</li>
<li>一主多从</li>
<li>一主多从级联同步</li>
<li>双主</li>
<li>环形多主</li>
<li>多主多从</li>
</ol>
<h3 id="集群同步"><a href="#集群同步" class="headerlink" title="集群同步"></a>集群同步</h3><ol>
<li>配置<ul>
<li>配置数据库主从节点的用户权限，一般主库可以增删查改，从库只能查询</li>
<li>每个数据库节点分配不同的<code>server_id</code></li>
<li>从库根据主库地址、端口、用户名、密码连接到主库</li>
<li>主库之间互为从库，根据其他主库地址、端口、用户名、密码连接到其他主库</li>
</ul>
</li>
<li>binlog数据同步<ul>
<li>主库将数据更改操作记录保存在binlog中，包括对表的增删改操作，以及对数据库结构的更改操作（创建、删除表）</li>
<li>从库连接到主库，并请求复制数据：从库发送一个<code>change master to</code>命令告诉主库它想要复制的日志文件和位置</li>
<li>主库收到从库的请求、或者主动通知从库，通过<code>log dump thread</code>子线程将binlog文件和位置发送给从库</li>
<li>从库收到binlog文件和位置后，开始应用这些更改操作，从库将主库的binlog文件保存在自己的数据库中，并使用主库的binlog位置开始复制</li>
<li>从库先写入<code>replay log</code>中，再通过<code>Sql thread</code>线程写入数据库</li>
<li>当从库复制完一个binlog文件后，会发送一个ACK确认信号给主库，告诉主库它已经复制完该文件</li>
<li>主库收到确认后，会继续将下一个binlog文件发送给从库，直到所有binlog文件都被复制完成</li>
</ul>
</li>
</ol>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><ol>
<li>垂直分库分表：根据业务模块划分</li>
<li>水平分库分表：同一个业务模块划分多个库表，可按照时间、Hash数据分片、主键区间</li>
</ol>
<p>优化优先级：垂直分库-&gt;垂直分表-&gt;冗余设计-&gt;存储引擎-&gt;索引-&gt;SQL-&gt;缓存-&gt;搜索引擎-&gt;静态页面-&gt;集群-&gt;水平分库-&gt;水平分表-&gt;</p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>依赖于第三方组件（Sharding Sphere、MyCat、mysql proxy）</p>
<h3 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding JDBC"></a>Sharding JDBC</h3><ol>
<li>概念：开源的适用于微服务的分布式数据访问基础类库，轻量级的Java框架，不需要中间层、额外部署或者其他依赖，提供分库分表、读写分离、分布式主键等功能。</li>
<li>集成：<ul>
<li>引入依赖<code>sharding-jdbc-spring-boot-starter</code></li>
<li>配置参数</li>
</ul>
</li>
<li>雪花算法：64位long类型分布式UUID，第一位固定0+时间戳+工作机器+序列号<ul>
<li>第一位不用，默认0，表示正数</li>
<li>41位表示毫秒级时间戳</li>
<li>10位表示工作机器：前5位表示机房id、后5位表示同一机房的主机id</li>
<li>12位表示序列号：顺序自增的数字</li>
</ul>
</li>
<li>时钟回拨：雪花算法强依赖时间戳，如果服务器时间回拨，会导致雪花算法出现时钟回拨问题，即可能生成相同的id<ul>
<li>延迟等待：如果生成id时发现当前时间戳比上一次生成id的时间戳小，就阻塞几毫秒再重试生成id，如果重试几次仍然失败，就需要发出预警由人工干预</li>
<li>追赶策略：如果生成id时发现当前时间戳比上一次生成id的时间戳小，就尝试增加时间戳增长步长，如果重试几次仍然失败，就需要发出预警由人工干预</li>
<li>序列号持久化：保证重启后的序列号仍然单调自增</li>
<li>使用备用机</li>
</ul>
</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"># mysql-server配置</span><br><span class="line">[mysqld]</span><br><span class="line"># TCP/IP监听端口，默认值3306</span><br><span class="line"># port=3306</span><br><span class="line"></span><br><span class="line"># 控制mysql监听哪些IP，默认值0.0.0.0，即监听所有IP，可以绑定内网IP防止公网攻击</span><br><span class="line"># bind_address=0.0.0.0</span><br><span class="line"></span><br><span class="line"># mysql的管理用户，通过mysqlId创建的文件或者目录都是被mysql系统拥有的</span><br><span class="line">user=mysql</span><br><span class="line"></span><br><span class="line"># 字符集</span><br><span class="line">character_set_server=utf8mb4</span><br><span class="line"># 排序规则</span><br><span class="line">collation_server=utf8mb4_unicode_ci</span><br><span class="line"></span><br><span class="line"># 密码认证方式，mysql8默认caching_sha2_password，老版的默认是mysql_native_password</span><br><span class="line"># default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line"># 默认时区，默认system，即服务器的时区</span><br><span class="line"># time_zone=&#x27;+08:00&#x27;</span><br><span class="line">time_zone=&#x27;Asia/Shanghai&#x27;</span><br><span class="line"></span><br><span class="line"># 数据存储目录</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line"># sock文件位置</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"># 导入导出操作的目录，默认为NULL，即不允许导入导出，可设置具体目录限制只能导入导出到对应目录，设置空串表示不限制</span><br><span class="line"># secure-file-priv=/var/lib/mysql-files</span><br><span class="line"></span><br><span class="line"># pid文件位置</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line"># SQL语法校验规则</span><br><span class="line"># ONLY_FULL_GROUP_BY：默认，聚合查询操作中如果SELECT的列必须在GROUP BY中</span><br><span class="line"># STRICT_TRANS_TABLES：默认，如果不能将给定的值插入到事务表中则放弃该语句；对非事务表不做限制</span><br><span class="line"># NO_ZERO_IN_DATE：默认，不允许日期和月份为零</span><br><span class="line"># NO_ZERO_DATE：默认，不允许插入零日期</span><br><span class="line"># ERROR_FOR_DIVISION_BY_ZERO：默认，INSERT/UPDATE过程中不允许数据被零除，不设置则返回NULL</span><br><span class="line"># NO_ENGINE_SUBSTITUTION：默认，如果需要的存储引擎被禁用或未编译则抛出错误；不设置此值时用默认的存储引擎替代并抛出一个异常</span><br><span class="line"># NO_AUTO_VALUE_ON_ZERO：非默认，允许自增长列设置为0，不设置时自增长列插入0或NULL会自动替换成自增长序号</span><br><span class="line"># NO_AUTO_CREATE_USER：非默认，禁止GRANT创建密码为空的用户</span><br><span class="line"># PIPES_AS_CONCAT：非默认，将&quot;||&quot;视为字符串的连接操作符而非或运算符</span><br><span class="line"># ANSI_QUOTES：非默认，将双引号视作识别符，即不能用双引号来引用字符串</span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line"># 错误日志文件位置</span><br><span class="line">log_error=/var/log/mysqld.log</span><br><span class="line"># 日志过期天数，过期自动清理，默认0表示不清理</span><br><span class="line">expire_logs_days=2</span><br><span class="line"></span><br><span class="line"># 慢查询日志收集，默认0/OFF表示关闭、1/ON表示开启</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 慢查询日志文件位置，默认在/var/lib/mysql/*-slow.log</span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow_query.log</span><br><span class="line"># 慢查询超时时间，默认10秒</span><br><span class="line">long_query_time=3</span><br><span class="line"></span><br><span class="line"># 开启二进制文件日志</span><br><span class="line">log_bin=ON</span><br><span class="line"># 日志文件前缀，默认值</span><br><span class="line">log_bin_basename=/var/lib/mysql/binlog</span><br><span class="line"># 日志文件索引，默认值</span><br><span class="line">log_bin_index=/var/lib/mysql/binlog.index</span><br><span class="line"># 日志文件最大容量，默认1024M</span><br><span class="line">max_binlog_size=256M</span><br><span class="line"># 日志格式，默认值，可选statement、row、mixed</span><br><span class="line">binlog_format=ROW</span><br><span class="line"># 刷盘策略，默认值</span><br><span class="line">sync_binlog=1</span><br><span class="line"># 文件过期时间，默认2592000s即30天</span><br><span class="line">binlog_expire_logs_seconds=604800</span><br><span class="line"></span><br><span class="line"># 只记录指定数据库的binlog，不配置默认记录所有数据库</span><br><span class="line"># binlog_do_db=db1</span><br><span class="line"># 不记录指定数据库的binlog</span><br><span class="line"># binlog_ignore_db=db2</span><br><span class="line"># 忽略指定数据库表的binlog，可以使用通配符&#x27;%&#x27;</span><br><span class="line"># replicate_wild_ignore=&#x27;db.table&#x27;</span><br><span class="line"></span><br><span class="line"># mysql集群实例唯一ID</span><br><span class="line">server_id=1</span><br><span class="line"># 主从复制模式：严格模式，默认值：STRICT；宽松模式/幂等模式：IDEMPOTENT</span><br><span class="line"># slave_exec_mode=STRICT</span><br><span class="line"># 忽略主从复制中出现的错误：OFF：不忽略，默认值、ALL：全忽略、errorcode：忽略指定错误、DDL_EXIST_ERRORS：忽略指定错误</span><br><span class="line"># slave_skip_errors=OFF</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/05/06/MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/06/MQ/" class="post-title-link" itemprop="url">MQ</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-06 05:01:00" itemprop="dateCreated datePublished" datetime="2024-05-06T05:01:00+08:00">2024-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-09 02:39:44" itemprop="dateModified" datetime="2024-05-09T02:39:44+08:00">2024-05-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>MQ（Message Queue，消息队列）是基于队列和消息传递技术的可靠消息通信模型，可以用于异步处理、应用解耦、流量削峰。</p>
<p>实现MQ的主流方式有两种：</p>
<ol>
<li>AMQP：Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件之间可以传递消息。</li>
<li>JMS：Java Message Service，是一个Java平台中关于面向消息中间件的API规范，用于在两个应用程序之间或分布式系统中发送消息，进行异步通信。</li>
</ol>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>使用Erlang语言基于AMQP协议的消息中间间，单机支持万级并发的吞吐量，高可用上支持集群模式，支持消息持久化、消息可靠传输、消息重试、死信队列等功能。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ol>
<li>客户端<ul>
<li>生产者（Producer）：发送消息的客户端</li>
<li>消费者（Consumer）：接受消息的客户端</li>
</ul>
</li>
<li>服务进程（Broker）：MQ服务进程<ul>
<li>消息（Message）：消息，生产者发送给消费者的信息</li>
<li>交换机（Exchange）：负责从生产者那里接收消息，并根据交换类型分发到对应的消息列队里</li>
<li>队列（Queue）：缓存消息</li>
<li>绑定（Binding）：队列和交换机的一个关联连接</li>
<li>路由键（Routing Key）：供交换机查看并根据键来决定如何分发消息到列队，可以说是消息的目的地址</li>
</ul>
</li>
<li>连接（Connection）：连接客户端和服务进程的TCP连接<ul>
<li>通道（Channel）：客户端和服务进程之间的虚拟通道，用于发送或接收消息</li>
</ul>
</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>生产者与服务进程建立TCP连接后创建通道发送消息</li>
<li>由交换机根据绑定关系和路由键转发消息到队列</li>
<li>消费者与服务进程建立TCP连接后创建通道从队列消费消息</li>
</ol>
<h3 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h3><ol>
<li>直接（Direct）：直接交换机根据消息上的路由键直接对消息分发到对应的队列</li>
<li>扇型（Fanout）：扇型交换机会将消息发送到所有和它进行绑定的队列上<ul>
<li>路由键不起作用</li>
</ul>
</li>
<li>主题（Topic）：主体交换机会将路由键和绑定的队列进行通配符匹配<ul>
<li><code>*</code>：表示必须出现的一个单词</li>
<li><code>#</code>：表示可能出现0个以上的单词</li>
</ul>
</li>
<li>消息头（Headers）：消息头交换机使用消息头的属性进行消息路由。</li>
</ol>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><ol>
<li>基本消息类型：生产者-&gt;交换机-&gt;消息队列-&gt;一个消费者</li>
<li>工作队列类型：生产者-&gt;交换机-&gt;消息队列-&gt;多个消费者</li>
<li>订阅发布类型：生产者-&gt;交换机-&gt;所有消息队列-&gt;消费者</li>
<li>定向订阅类型：生产者-&gt;交换机-&gt;指定路由键消息队列-&gt;消费者</li>
<li>主题订阅类型：生产者-&gt;交换机-&gt;通配符匹配消息队列-&gt;消费者</li>
</ol>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ol>
<li>队列持久化：<code>durable</code>参数设置为true<ul>
<li><code>Queue.DeclareOk Channel.queueDeclare(queueName, durable, exclusive, autoDelete, argumentsMap)</code></li>
</ul>
</li>
<li>消息持久化：<code>BasicProperties.deliveryMode</code>属性1非持久、2持久化</li>
<li>交换机持久化：<code>durable</code>参数设置为true<ul>
<li><code>Exchange.DeclareOk Channel.exchangeDeclare(exchangeName, exchangeType, durable)</code></li>
</ul>
</li>
<li><code>LazyQueue</code>：收到消息直接存入磁盘，消费时才从磁盘加载到内存</li>
</ol>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><ol>
<li>保证生产者成功发送消息到MQ<ul>
<li><code>retry.enabled</code>：开启超时重试机制<ul>
<li><code>retry.initial-interval</code>：失败后的初始等待时间</li>
<li><code>retry.multiplier</code>：失败后下次的等待时长倍数</li>
<li><code>retry.max-attempts</code>：最大重试次数</li>
</ul>
</li>
<li><code>publisher-confirm-type: none/simple/correlated</code><ul>
<li><code>rabbitTemplate.setConfirmCallback()</code></li>
</ul>
</li>
<li><code>publisher-return: true</code><ul>
<li>rabbitTemplate.setReturnCallback()</li>
</ul>
</li>
<li><code>basicPublish()</code>：mandatory、immediate<ul>
<li><code>mandatory</code>：至少将消息路由到一个队列，否则将消息返回生产者</li>
<li><code>immediate</code>：至少将消息路由到一个队列的消费者，否则将消息返回生产者</li>
<li>通过<code>addReturnListener()</code>监听返回事件</li>
</ul>
</li>
</ul>
</li>
<li>保证MQ完成消息持久化</li>
<li>保证消费者成功消费消息<ul>
<li><code>acknowledge-mode: none/manual/auto</code>：消费回执<ul>
<li><code>none</code>：不处理，消费者立即返回ack，MQ直接删除消息</li>
<li><code>auto</code>：根据处理结果返回，成功ack、业务异常nack、消息异常reject<ul>
<li><code>ack</code>：表示消息处理成功，MQ可以删除消息</li>
<li><code>nack</code>：处理消息处理失败，MQ需要重新投递消息</li>
<li><code>reject</code>：表示消息处理失败并拒绝处理，MQ可以删除消息</li>
</ul>
</li>
<li><code>manual</code>：手动调用API处理，返回ack、nack、reject</li>
</ul>
</li>
<li><code>retry.enabled</code>：开启超时重试机制<ul>
<li><code>retry.initial-interval</code>：失败后的初始等待时间</li>
<li><code>retry.multiplier</code>：失败后下次的等待时长倍数</li>
<li><code>retry.max-attempts</code>：最大重试次数</li>
</ul>
</li>
<li>失败处理策略<ul>
<li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽返回reject</li>
<li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽返回nack</li>
<li><code>RepublishMessageRecoverer</code>：重试耗尽将消息投递到指定交换机</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>将消息放到同一个交换机，此交换机仅一个队列并且此队列仅只有一个消费者</p>
<h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>每个消息用一个唯一标识来区分，消费前先判断标识有没有被消费过，若已消费过，则直接ACK</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/05/04/NoSql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/04/NoSql/" class="post-title-link" itemprop="url">NoSql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-04 21:58:52" itemprop="dateCreated datePublished" datetime="2024-05-04T21:58:52+08:00">2024-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-07 21:14:13" itemprop="dateModified" datetime="2024-05-07T21:14:13+08:00">2024-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>NoSQL是非关系型数据库，与关系型数据库相比，它们不保证关系数据的ACID特性，但在在大数据、高并发等场景下，NoSQL数据库展现了其独特的优势。</p>
<p>NoSQL数据库主要分为以下四种类型：键值存储数据库、列存储数据库、文档型数据库和图形数据库。</p>
<ol>
<li>键值存储数据库：数据以键值对的形式存储，通过哈希函数实现键到值的映射，查询数据时，基于键的哈希值可以直接定位到数据所在的位置，实现快速查询，并支持海量数据的高并发查询。<ul>
<li>Redis、Memcached</li>
</ul>
</li>
<li>文档型数据库：数据以文档的形式存储和管理，文档是结构化的数据，通常以JSON格式存储，文档存储不要求所有文档都具有相同的结构，提供很大的灵活性。<ul>
<li>MongoDB、ElasticSearch</li>
</ul>
</li>
<li>列存储数据库：数据以列为单位进行存储，这种结构的优点在于查找速度快、可扩展性强，容易进行分布式扩展。<ul>
<li>HBase、HadoopDB、BigTable</li>
</ul>
</li>
<li>图形数据库：图形数据库以图论为基础，使用图作为数据模型来存储数据，适合于存储大量复杂、互连接、低结构化的图结构数据。<ul>
<li>Neo4J、OrientDB、InfoGrid</li>
</ul>
</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个高性能的key-value分布式内存数据库，它的特点是把数据放在内存中操作，处理速度相对于磁盘I&#x2F;O提高了好几个量级，通过把常用数据缓存在内存，不但可以缓解关系数据库（Mysql、Oracle）的压力，还可以提高数据访问的速度。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>Redis是单线程模型，指的是网络IO和键值对读写及其顺序都是由一个主线程完成，持久化、异步删除、集群数据同步等功能还是由其他线程执行</p>
<ul>
<li>单线程保证线程安全并省去了切换线程上下文的资源开销</li>
<li>基于内存，纯内存IO速度非常快</li>
<li>数据结构基于散列表，CURD操作的时间复杂度是O(1)</li>
<li>IO多路复用+epoll函数，在单个线程中跟踪记录每一个Socket的状态来管理多个IO流，从而提高吞吐能力<ul>
<li>Redis的瓶颈在于内存（读写和容量）和网络IO，网络IO在操作系统层面是指内核态和用户态之间进行数据交换，在应用层面是指服务端处理客户端请求的Socket</li>
<li>客户端请求服务端时，是在服务端的Socket文件中写入文件描述符，服务端分配一个线程来监听文件句柄，当有数据时就调用对应的处理并返回响应</li>
<li>多个客户端连接服务器时，服务端将所有的Socket对应的文件描述符注册进epoll函数，同时监听所有的文件句柄，谁有数据就调用对应的处理并返回响应</li>
</ul>
</li>
</ul>
</li>
<li><p>Redis大Key问题，指单个Key对应的Value的数据量特别大，可能会导致内存使用率低下、阻塞其他操作、增加网络传输负载等性能问题</p>
<ul>
<li>数据分片：在单例模式下将大对象拆分成多个小对象，在集群模式下使用<code>hash tag</code>在多个实例中分散数据</li>
<li>数据结构：使用Hash代替大的String，使用ZSet代替大的List</li>
<li>定期压缩：使用Redis的RDB或AOF持久化功能，定期压缩数据并存储到硬盘</li>
<li>监控预警：使用info命令或第三方工具监控Redis信息，设置预警值和触发警告后的处理</li>
</ul>
</li>
<li><p>LazyFree机制用于解决在删除大Key时会造成阻塞的情况，即在删除时执行逻辑删除并立即返回结果，再由LazyFree线程完成真正的物理删除</p>
<ul>
<li><code>unlink Largekey</code>：命令，异步删除指定大Key</li>
<li><code>Flushdb async</code>：命令，异步删除当前分库</li>
<li><code>Flushall async</code>：命令，异步删除所有库</li>
<li><code>slave-lazy-flush</code>：配置，slave节点接收完RDB文件后异步删除数据</li>
<li><code>lazyfree-lazy-eviction</code>：配置，内存淘汰策略异步删除</li>
<li><code>lazyfree-lazy-expire</code>：配置，数据过期机制异步删除</li>
<li><code>lazyfree-lazy-server-del</code>：配置，内部优化异步删除，如<code>rename oldkey newkey</code>时如果<code>newkey</code>已经存在则会异步删除</li>
</ul>
</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li><code>String</code>：最基本的数据类型，可以保存字符串或数值，用于常规字符串&#x2F;数值的存取，场景：计数器、共享session&#x2F;token、全局序列号<ul>
<li><code>set key value</code>：设置key的value</li>
<li><code>get key</code>：获取key的value</li>
<li><code>del key</code>：删除key</li>
<li><code>mset key value</code>：批量设置key的value</li>
<li><code>mget key</code>：批量获取key的value</li>
<li><code>strlen key</code>：获取key的value的长度</li>
<li><code>append key newValue</code>：在key的value后拼接newValue</li>
<li><code>incr key</code>：key的value自增1</li>
<li><code>decr key</code>：key的value自减1</li>
<li><code>incrby key num</code>：key的value自增num</li>
<li><code>decrby key num</code>：key的value自减num</li>
<li><code>getrange key index1 index2</code>：获取key的value在index1和index2之间的值，0到-1表示完整的值</li>
<li><code>setex key seconds value</code>：设置key的value和过期时间</li>
<li><code>setnx key value</code>：key不存则设置value并返回1，key存在则不做操作并返回0</li>
<li><code>getset key calue</code>：设置key的新值并返回旧值</li>
<li><code>expire key seconds</code>：设置key的过期时间</li>
<li><code>persist key</code>：取消key的过期时间（永不过期）</li>
</ul>
</li>
<li><code>List</code>：String类型的双向链表，按照插入顺序存储的有序列表，可以作为列表、栈和队列<ul>
<li><code>lpush key value</code>：将value插入指定key的List的左侧</li>
<li><code>rpush key value</code>：将value插入指定key的List的右侧</li>
<li><code>lrange key index1 index2</code>：获取指定key的List中索引在index1和index2之间的值，0到-1表示集合所有值</li>
<li><code>lpop key</code>：从指定key的List的左侧取出值</li>
<li><code>rpop key</code>：从指定key的List的右侧取出值</li>
<li><code>brpop key tiemout</code>：从指定key的List的右侧取出值，如果没有值则等待指定时间</li>
<li><code>lindex key index</code>：获取指定key的List的index下标的值</li>
<li><code>llen</code>：获取指定key的List的长度</li>
<li><code>lset key index value</code>：更新指定key的List的index下标的值为value</li>
<li><code>linsert key before value1 value2</code>：在指定key的List的value1前面插入value2</li>
<li><code>linsert key after value1 value2</code>：在指定key的List的value1后面插入value2</li>
</ul>
</li>
<li><code>Hash</code>：键值对的哈希表，可以在一个哈希数据结构存储多个字段和值，用于同类数据归类统计管理，如购物车功能key保存用户、field保存商品、value保存商品数量<ul>
<li><code>hset key field value</code>：设置指定key的Hash的field和value</li>
<li><code>hget key field</code>：获取指定key的Hash的指定field的value</li>
<li><code>hdel key field</code>：删除指定key的Hash的指定一个或多个field</li>
<li><code>hexists key field</code>：检查指定key的Hash是否存在指定field</li>
<li><code>hkeys key</code>：获取指定key的Hash的所有field</li>
<li><code>hvals key</code>：获取指定key的Hash的所有field的value</li>
<li><code>hgetall key</code>：获取指定key的Hash的所有field和value</li>
<li><code>hincrby key field num</code>：将指定key的Hash的指定field的value自增num</li>
<li><code>hlen key</code>：获取指定key的Hash的字段数量</li>
<li><code>hmset key field value</code>：设置指定key的Hash的多个field和value</li>
<li><code>hmget key field</code>：获取指定key的Hash的指定field的value</li>
</ul>
</li>
<li><code>Set</code>：无序的唯一值集合，用于计算差集、交集、并集和随机取值，如抽奖活动和朋友圈点赞<ul>
<li><code>sadd key member</code>：向指定key的Set中添加一个或多个member，member存在则忽略</li>
<li><code>srem key member</code>：从指定key的Set中移除一个或多个member</li>
<li><code>sismember key member</code>：检查指定key的Set中是否存在member</li>
<li><code>smembers key</code>：获取指定key的Set的所有member</li>
<li><code>scard key</code>：获取指定key的Set的member数量</li>
<li><code>spop key [count]</code>：从指定key的Set中随机移除并返回指定count数量的member</li>
<li><code>srandmember key [count]</code>：从指定key的Set中随机获取指定count数量的member，但不移除</li>
<li><code>sdiff key</code>：获取多个指定key的Set的差集</li>
<li><code>sinter key</code>：获取多个指定key的Set的交集</li>
<li><code>sunion key</code>：获取多个指定key的Set的并集</li>
</ul>
</li>
<li><code>Zset</code>：有序的唯一值集合，每个值都关联一个score用于排序，用于排序计算排行榜和时间轴<ul>
<li><code>zadd key score member</code>：向指定key的Zset中添加指定score的member</li>
<li><code>zrem key member</code>：从指定key的Zset中移除指定member</li>
<li><code>zscore key member</code>：获取指定key的Zset中指定member的score</li>
<li><code>zrange key statr stop [withscores]</code>：按照分数从小到大的顺序获取指定key的Zset中索引在start和stop之间的member</li>
<li><code>zrebrange key start stop [withscores]</code>：按照分数从大到小的顺序获取指定key的Zset中索引在start和stop之间的member</li>
<li><code>zcrad key</code>：获取指定key的Zset中member的数量</li>
<li><code>zcount key min max</code>：计算指定key的Zset中score在min到max之间的member数量</li>
<li><code>zrank key member</code>：按照分数从小到大的顺序获取指定key的Zset中指定member的索引下标（排名）</li>
<li><code>zrevrank key member</code>：按照分数从大到小的顺序获取指定key的Zset中指定member的索引下标（排名）</li>
<li><code>zincrby key num member</code>：将指定key的Zset中指定的member的score增加num</li>
</ul>
</li>
<li><code>GeoSpatial</code>：保存了地理位置的经纬度并距离计算和范围查询功能<ul>
<li><code>geoadd key long lat city</code>：在指定key的集合中添加指定经纬度的地点</li>
<li><code>geopos key city</code>：获取指定key的集合中指定地点的经纬度</li>
<li><code>geodist key city1 city2</code>：计算指定key集合中两个地点的距离</li>
<li><code>georadius key long lat distance</code>：获取指定key的集合中以指定经纬度为圆心、指定distance为半径的范围内的地点</li>
<li><code>georadiusbymember key city distance</code>：获取指定key的集合中以指定地点为圆心、指定distance为半径的范围内的地点</li>
</ul>
</li>
<li><code>HyperLogLog</code>：这种数据结构提供一种不精确的去重计数算法，能够以极小的内存开销粗略计算一个集合中不重复元素的个数（基数），如统计日活量<ul>
<li><code>pfadd key element</code>：向指定key的HyperLogLog中添加指定元素</li>
<li><code>pfcount key</code>：获取指定key的HyperLogLog的基数估算值</li>
<li><code>pfmerge destkek sourcekey</code>：以并集的方式合并多个HyperLogLog为新的HyperLogLog</li>
</ul>
</li>
<li><code>Bitmaps</code>：基于String类型实现的二进制位操作的位图，最大长度是512M即2^32个比特位，可以用于管理用户的登陆状态<ul>
<li><code>setbit key offset value</code>：设置指定key位图的指定比特位的值</li>
<li><code>getbit key offset</code>：获取指定key位图的指定比特位的值</li>
<li><code>bitop and/or/xor/not destkey key1 [key2...]</code>：将多个位图按位操作并保存到新位图</li>
</ul>
</li>
<li><code>Stream</code>：5.0版本新增的数据结构，字面上是流类型，但功能上是一个支持多播的可持久化消息队列<ul>
<li>订阅&#x2F;发布模式只支持及时消息，无法持久化，出现客户端网络断开或Redis宕机时消息就会丢失</li>
<li>基于<code>List+lpush+brpop</code>的消息队列支持了持久化，但是不支持多播、分组消费</li>
</ul>
</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅&#x2F;发布模式"></a>订阅&#x2F;发布模式</h4><h4 id="List阻塞队列"><a href="#List阻塞队列" class="headerlink" title="List阻塞队列"></a>List阻塞队列</h4><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis的数据是存放在内存中的，内存本身在服务关闭、进程推出或突发断电的情况下会丢失所有数据，所以Redis也支持内存数据持久化到硬盘。</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB（Redis DataBase）是redis默认的快照持久化方式，可以通过命令手动触发或通过配置自动触发。</p>
<h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h5><ol>
<li>手动触发<ul>
<li><code>save</code>：由主线程完成持久化，持久化过程中会阻塞其他请求</li>
<li><code>bgsave</code>：主线程fork子线程后继续响应其他请求，由子线程完成持久化，主线程只在fork过程中阻塞</li>
</ul>
</li>
<li>自动触发：配置文件中设置<code>save m n</code><ul>
<li>该配置会在m秒内至少修改了n次数据后自动触发子线程持久化</li>
<li>redis通过默认100ms执行一次的周期性函数<code>serverCron</code>维护服务器的状态，其中一项是检查是否需要自动持久化</li>
<li><code>dirty</code>计数器记录了上一次持久化后数据的修改次数，<code>lastsave</code>记录了上一次持久化的时间戳，当<code>now - lastsave &gt; m &amp;&amp; dirty &gt; n</code>时就会执行持久化操作</li>
</ul>
</li>
</ol>
<h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><ol>
<li>主线程判断当前是否已经在执行持久化操作，如果正在持久化则直接结束，否则开始持久化</li>
<li>主线程fork一个子线程并阻塞所有请求，fork结束的同时与子线程共享当前的内存数据快照并继续处理客户端请求，通过操作系统的写时复制机制从快照中复制需要修改的数据的page并修改数据</li>
<li>子线程遍历内存快照的数据并序列化到临时文件，完成后原子替换RDB持久化文件</li>
<li>子线程通知主线程持久化完成，主线程更新统计信息</li>
<li>Redis重启时，读取RDB文件并将数据加载到内存</li>
</ol>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ol>
<li>优点：RDB文件是经过压缩的二进制文件，保存了Redis某一时刻的内存数据，适合设定指定时间对Redis进行归档备份，在数据量比较大时，Redis启动从RDB文件恢复数据到内存的速度比较快。</li>
<li>缺点：RDB持久化容易造成数据丢失，如果Redis出现故障，会丢失最后一次持久化到发生故障期间的数据，另外主线程fork子线程时也会阻塞其他请求。</li>
</ol>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append Of File）以日志的形式在内存缓冲区顺序记录了Redis的所有修改内存的指令，当缓冲区满了再写入磁盘。</p>
<h5 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h5><ol>
<li>缓冲区刷新策略：<code>appendfsync always/everyesc/no</code><ul>
<li><code>fsync()</code>：将指定文件的内容从内存缓存刷到硬盘中</li>
<li><code>always</code>：每执行一条写操作指令，就调用一次<code>fsync()</code></li>
<li><code>everyesc</code>：默认，每个一秒调用一次<code>fsync()</code></li>
<li><code>no</code>：不主动调用<code>fsync()</code>，由操作系统自行决定刷新缓冲区到磁盘的时机</li>
</ul>
</li>
<li>重写AOF文件：AOF文件在Redis允许过程中会越来越大，可以通过重写机制减小AOF文件容量<ul>
<li><code>bgrewriteaof</code>：手动重写AOF文件</li>
<li><code>auto-aof-rewrite-percentage 100</code>：自动触发重写的百分比，0表示关闭自动重写</li>
<li><code>auto-aof-rewrite-min-size 64mb</code>：AOF文件超过64MB自动触发重写</li>
</ul>
</li>
</ol>
<h5 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h5><ol>
<li>客户端请求中的写操作指令被追加到缓冲区</li>
<li>缓冲区根据刷新策略将数据从内存同步到磁盘的AOF文件</li>
<li>AOF文件大小超过重写策略或手动重写时，重写AOF文件，压缩AOF容量</li>
<li>Redis重启时，执行AOF文件的指令将数据加载到内存</li>
</ol>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ol>
<li>优点：AOF文件是可读的日志文本文件，持久化内存数据的时间间隔短，备份机制更稳健，丢失数据的概率更低、更能接受</li>
<li>缺点：容易占用磁盘空间，在数据量比较大时通过重新执行写指令恢复数据的速度比较慢，每隔一秒刷新缓冲区有一定的性能压力</li>
</ol>
<h4 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h4><p>通过RDB文件恢复数据，可能会丢失大量数据；通过AOF文件恢复数据，恢复性能较慢导致启动Redis更费时，因此在4.0版本之后，Redis支持了混合持久化，通过配置<code>aof-use-rdb-preamble</code>参数开启。</p>
<ol>
<li>正常使用RDB方式持久化，但持久化到磁盘时是保存在AOF文件中</li>
<li>在RDB持久化的间隔，使用AOF持久化</li>
</ol>
<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>通常在设置Redis缓存时需要指定缓存的过期时间，从而保证缓存数据只在设定的时间内有效，通过这个特性可以实现很多功能，而当缓存过期时需要通过一些策略删除过期缓存。</p>
<ol>
<li>惰性删除：不主动删除过期缓存，而是在获取缓存时判断是否过期，过期则删除并返回null<ul>
<li>优点：只在访问时删除过期缓存，节省了CPU资源</li>
<li>缺点：不能及时删除过期缓存，浪费了内存资源</li>
</ul>
</li>
<li>定时删除：在设置缓存的过期时间时创建一个定时器，当缓存过期时由定时器立即删除缓存<ul>
<li>优点：及时删除过期缓存，节省了内存资源</li>
<li>缺点：定时器占用了CPU资源</li>
</ul>
</li>
<li>定期删除：每个一段时间从设置过期时间的缓存中随机抽取20个，如果过期则删除，当删除比例超过25%时继续随机抽取20个缓存，直到删除比例小于25%<ul>
<li><code>hz</code>：配置，默认10，表示1秒检测10次</li>
<li><code>maxmemory</code>：配置，最大可使用的物理内存，超过时会触发淘汰策略</li>
</ul>
</li>
</ol>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>当Redis内存超出<code>maxmemory</code>限制时，会根据<code>maxmemory-policy</code>淘汰策略移除一些缓存。</p>
<ol>
<li><code>noeviction</code>：不进行淘汰，当内存不足时，新写入命令会报错</li>
<li><code>allkeys-lru</code>：根据LRU算法移除缓存</li>
<li><code>volatile-lru</code>：只对设置了过期时间的缓存进行LRU算法移除</li>
<li><code>allkeys-random</code>：随机移除缓存</li>
<li><code>volatile-random</code>：随机移除设置了过期时间的缓存</li>
<li><code>volatile-ttl</code>：移除即将过期的缓存</li>
<li><code>allkeys-lfu</code>：根据LFU算法移除缓存</li>
<li><code>volatile-lfu</code>：只对设置了过期时间的缓存进行LFU算法移除</li>
</ol>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>LRU（Least Recently Used）表示最近很少使用&#x2F;最久没有使用，即当内存不足时，为了保证新数据写入内存，需要移除内存中最久没有使用的旧数据。</p>
<h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>LFU（Least Frequently Used）表示最近最少使用，即当内存不足时，为了保证新数据写入内存，需要移除内存中访问频率最少的旧数据。</p>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson是基于Redis的Java客户端类库，它提供了对Redis的高级封装和抽象，如分布式数据结构、异步和响应式编程模型、Redis连接池管理、监控等众多功能，大大简化了Java应用程序使用Redis的流程。</p>
<ol>
<li><code>Jedis</code>：Redis官方推出的客户端，提供了各种基础命令的支持。</li>
<li><code>Lettuce</code>：基于Netty异步通讯框架的可扩展、线程安全的客户端，支持更高级的Redis特性，如哨兵、集群、管道、自动重连等。</li>
<li><code>Redisson</code>：基于Netty异步通讯框架的分布式客户端，支持分布式锁（自动释放、自动续期）。</li>
</ol>
<h4 id="非公平锁原理"><a href="#非公平锁原理" class="headerlink" title="非公平锁原理"></a>非公平锁原理</h4><p>Redisson通过Lua脚本保证缓存操作的原子性，使用Hash数据类型实现非公平锁。</p>
<p>假设线程A、B竞争锁，A获取锁，B未获取锁，以下为代码逻辑：</p>
<ol>
<li>A加锁，通过哈希算法选择节点，执行Lua脚本向redis服务端写入Hash类型的缓存并返回锁剩余过期时间，如果缓存没有过期则设置<code>Watch Dog</code>自动续期<ul>
<li><code>key</code>：自定义的key，也就是锁</li>
<li><code>field</code>：获取锁的线程的id</li>
<li><code>value</code>：线程获取锁的次数</li>
<li><code>Watch Dog</code>：每隔十秒检查是否持有锁，是则自动为锁续期，默认增加30秒锁的缓存的过期时间</li>
</ul>
</li>
<li>B未获取锁，开始检查等待时间，等待超时则返回加锁失败，否则基于信号量订阅锁的解锁广播消息</li>
<li>B再次尝试获取锁但加锁失败，未等待超时则调用信号量的<code>tryAcquire()</code>阻塞住，直到等待超时取消订阅释放信号量</li>
<li>A操作完成释放锁，发布解锁的广播消息</li>
<li>B收到订阅消息通知被唤醒，未等待超时则回到第二步继续竞争锁</li>
<li>B获取到锁，取消订阅释放信号量，业务操作完成后释放锁</li>
</ol>
<h4 id="公平锁原理"><a href="#公平锁原理" class="headerlink" title="公平锁原理"></a>公平锁原理</h4><p>Redisson通过Lua脚本保证缓存操作的原子性，使用Hash、List和Zset数据类型实现公平锁。</p>
<p>其中Hash保存获取的线程，key为自定义锁，field为线程id，value为获取锁的次数，List作为IFIO线程等待队列保存竞争锁的线程，key为redisson_lock_queue+自定义的锁，value是线程id；Zset作为超时集合记录线程超时时间，key为redisson_lock_timeout+自定义的锁，score为线程超时时间，member为线程id。</p>
<p>以下为Lua脚本获取锁或排队逻辑：</p>
<ol>
<li>循环清除等待超时的线程<ul>
<li>获取List队列头节点线程，如果没有则跳出循环</li>
<li>如果有头节点线程，从Zset中获取头节点线程的超时时间，如果超时时间大于当前时间则跳出循环</li>
<li>否则从List和Zset中移除该线程，进入下一轮循环</li>
</ul>
</li>
<li>当前线程首次加锁，如果锁不存在 &amp;&amp; （不存在线程等待队列 || 存在线程等待队列并且头节点就是当前线程）<ul>
<li>取出List头节点线程、删除Zset中的头节点线程</li>
<li>遍历Zset所有member的score，都减去当前时间</li>
<li>在Hash中设置锁、当前线程id、获取次数、过期时间</li>
<li>返回nil</li>
</ul>
</li>
<li>线程A重入判断<ul>
<li>如果Hash中已经存在线程A，value自增1并重设过期时间</li>
<li>返回nil</li>
</ul>
</li>
<li>如果无法获取锁，检查线程B是否已经在Zset中<ul>
<li>获取线程B的超时时间，如果存在，直接返回线程B的剩余等待时间</li>
<li>不存在则进入下一步</li>
</ul>
</li>
<li>当前线程加入对尾<ul>
<li>计算ttl：如果List尾节点存在并且不是当前线程，ttl&#x3D;尾节点线程的score-当前时间，否则ttl&#x3D;锁的剩余存活时间</li>
<li>计算当前线程的score&#x3D;ttl+当前线程超时时间+当前时间</li>
<li>当前线程加入Zset和List队尾</li>
</ul>
</li>
</ol>
<h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol>
<li><code>RLock</code>：分布式锁核心接口，继承了<code>j.u.c.Lock</code>接口和自己的<code>RLockAsync</code>接口<ul>
<li><code>tryAcquireOnceAsync()</code>：加锁，通过<code>eval</code>命令执行<code>Lua</code>脚本，向redis服务端写入锁<ul>
<li>加锁成功流程：如果锁不存在，为当前线程增加锁并计数1；如果锁存在并且是同一线程，计数+1；设置失效时间并返回剩余时间</li>
<li>加锁失败流程：如果锁存在且不是同一线程，当前线程订阅锁删除的广播消息然后进入阻塞状态，直到解锁广播唤醒或等待超时取消订阅</li>
</ul>
</li>
<li><code>unlockInnerAsync</code>: 解锁，通过<code>eval</code>命令执行<code>Lua</code>脚本，向redis服务端移除锁<ul>
<li>流程：如果锁不存在直接返回；如果锁存在并且是同一线程，计数-1；如果计数大于0，重设失效时间；如果计数等于0，删除锁并发布解锁消息</li>
</ul>
</li>
</ul>
</li>
<li><code>RLockAsync</code>：实现异步的核心，接口返回类型都是<code>RFuture</code>，<ul>
<li><code>RFuture</code>：实现了<code>j.u.c.Future</code>和<code>j.u.c.CompletionStage</code>接口<ul>
<li><code>onComplete()</code>：异步任务完成后的回调，基于Netty监听器事件驱动</li>
</ul>
</li>
</ul>
</li>
<li>信号量：<code>RFuture&lt;RedissonLockEntry&gt;</code>类型，包含了一个<code>j.u.c.Semaphore</code></li>
<li><code>LockPubSub</code>：锁订阅发布功能，继承自<code>PublishSubscribe</code>，有一个<code>OnMessage()</code>用于监听消息，执行监听回调和释放信号量</li>
<li><code>PublishSubscribe</code>：管理订阅和信号量<ul>
<li><code>subscribe()</code>：订阅</li>
<li><code>unsubscribe()</code>：取消订阅并释放信号量</li>
<li><code>PublishSubscribeService</code>：管理了一个<code>AsyncSemaphore</code>数组<ul>
<li>根据<code>redisson_lock__channel_ + &#123; + key + &#125;</code>的哈希值绝对值对数组长度取模确定信号量位置</li>
<li><code>AsyncSemaphore</code>：基于<code>AtomicInteger + CountDownLatch + Runnable</code>实现的异步信号量</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>单节点Redis的并发能力是有限的，要进一步提高Redis的并发能力，就需要搭建分布式集群。</p>
<h4 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h4><ol>
<li>概念：CAP原则是分布式存储的理论基础，它指出在分布式系统中一致性、可用性、分区容忍度只能满足两个，另一个必须牺牲。<ul>
<li>C：<code>Consistent</code>，强一致性，所有节点在同一时刻的数据是相同的</li>
<li>A：<code>Availability</code>，高可用性，系统的服务一直可用，用于用户的请求处理不管成功还是失败都可以及时响应</li>
<li>P：<code>Partition Tolerance</code>，分区容错性，遇到节点之间网络断开的情况（网络分区）仍然可以响应用户请求</li>
</ul>
</li>
<li>策略<ul>
<li>CA（单点系统）：牺牲分区容错性，保证一致性和可用性，相当于放弃分布式</li>
<li>CP（支付系统）：牺牲可用性，保证一致性和分区容错性，降低用户体验，直到故障节点再次可用时才响应请求</li>
<li>AP（内容系统、商场系统）：牺牲一致性，保证可用性和分区容错性，即使各个节点数据暂时不一致也能立即响应用户</li>
</ul>
</li>
</ol>
<p>分布式系统的节点往往都是分布在不同网络的机器上的，这意味着必然会有网络断开的风险（网络分区），因此通常会保证分区容错性，再从一致性和可用性中选择牺牲一个。</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ol>
<li>概念：一个主机负责写操作，多个从机负责读操作和数据备份</li>
<li>配置：正常配置，但从机需要增加<code>replicaof/saveof &lt;masterip&gt; &lt;masterport&gt;</code>和<code>masterauth &lt;master-password&gt;</code>等配置</li>
<li>同步流程：<ul>
<li>从机执行<code>replicaof</code>命令建立与主机的连接，并发送<code>replid</code>和<code>offset</code>请求数据同步</li>
<li>主机根据<code>replid</code>判断是否是第一次同步，是第一次则先返回<code>replid</code>信息给从机保存<ul>
<li>主机执行<code>bgsave</code>命令，生成RDB文件并发送给从机，从机清空本地数据并加载主机的RDB文件</li>
<li>主机在<code>repl_baklog</code>中记录RDB期间的所有命令并发送给从机，从机执行接收到的命令</li>
</ul>
</li>
<li>非第一次同步，主机只发送<code>repl_baklog</code>中的命令给从机<ul>
<li>根据主从<code>offset</code>在命令中的偏移量判断从机数据是否落后于主机，落后则同步数据</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><ol>
<li>概念：在主从复制模式基础上增加了节点状态监控、主节点发生故障后自动从机选主和主从切换</li>
<li>配置：先按照主从模式配置，在单独配置奇数个哨兵配置（sentinel.conf）<ul>
<li><code>sentinel monitor mastername masterip masterport sentinelnum</code>：<ul>
<li><code>mastername</code>：设置主机名称</li>
<li><code>masterip</code>：主机IP</li>
<li><code>masterport</code>：主机端口</li>
<li><code>sentinelnum</code>：设置最少几个哨兵认为主机不可用时自动进行故障转移</li>
</ul>
</li>
<li><code>sentinel down-after-milliseconds mymaster num</code>：服务器超过num毫秒未响应则认为不可用</li>
<li><code>sentinel parallel-syncs mymaster num</code>：在故障转移期间可以有num个从机同时进行同步</li>
<li><code>sentinel failover-timeout mymaster num</code>：如果故障转移超过num毫秒则认为故障转移失败</li>
<li><code>redis-sentinel sentinel.conf</code>：按照配置启动哨兵</li>
</ul>
</li>
<li>心跳检测<ul>
<li>每个哨兵节点每隔10s向主从节点发送info命令更新主从结构</li>
<li>每个哨兵节点每隔2s发布自身信息和对主节点的判断，其他哨兵订阅该信息</li>
<li>每个哨兵节点每个1s向主从节点发送ping命令来判断主从节点是否可用</li>
</ul>
</li>
<li>选举机制<ul>
<li>主机下线：哨兵认为主节点不可用<ul>
<li>主观下线：一个哨兵检测到主节点不可用，不做操作，正常发布自身信息和对主节点的判断</li>
<li>客观下线：达到配置数量的哨兵检测到主节点不可用，在可用的从节点中选举一个切换成节点，哨兵根据发布订阅模式更新信息</li>
</ul>
</li>
<li>leader选举：<ul>
<li>每个哨兵可以要求其他哨兵选择自己，先到先得</li>
<li>超过一半的哨兵选择了某个哨兵时，这个哨兵作为leader进行故障转移</li>
</ul>
</li>
<li>节点选举：leader哨兵选择某个从节点切换成主节点<ul>
<li>选择在线的节点</li>
<li>选择响应速度最快的节点</li>
<li>选择与主节点断开时间最短的</li>
<li>选择<code>offset</code>偏移量最大的</li>
<li>选择<code>runid</code>最大的</li>
</ul>
</li>
<li>主从切换：<ul>
<li>从节点执行<code>saveod no noe</code>命令切换成新主节点</li>
<li>其他从节点和原主节点通过<code>saveof newmaster</code>命令变成新主节点的从节点</li>
<li>通知客户端新的主节点地址</li>
</ul>
</li>
</ul>
</li>
<li>脑裂：当主节点和哨兵发生网络分区时，哨兵的心跳检测没有感知到主节点，从而选举了新的主节点<ul>
<li>问题：客户端还是在原主节点执行写操作，新主节点无法同步数据，网络恢复后，原主节点变成新主节点的从节点，导致数据丢失</li>
<li>解决：通过配置让原主节点无法写入数据，但会导致客户端请求失败<ul>
<li><code>min-slaves-to-write num</code>：主节点至少有num个可用的从节点才能执行写操作</li>
<li><code>min-slaves-max-lag num</code>：主从复制时延迟时间超过num秒就不能执行写操作</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h4><ol>
<li>概念：多个主机负责写操作，多个从机负责读操作和数据备份，每个主机保存不同的数据</li>
<li>优点：主从复制、哨兵模式可以解决高可用、高并发读问题，而分片集群还可以解决海量数据存储和高并发写问题</li>
<li>配置：开启集群功能<code>cluster-enabled yes</code>、<code>replica-announce-ip masterip</code><ul>
<li><code>redis-cli -a pwd --cluster create/add-node/del-node --cluster-replicas num masterip1:port1  [masterip2:port2...]</code><ul>
<li><code>-a</code>：密码</li>
<li><code>--cluster</code>：集群模式</li>
<li><code>create</code>：创建集群</li>
<li><code>add-node</code>：添加集群节点</li>
<li><code>del-node</code>：删除集群节点（移哈希槽-&gt;删除从节点-&gt;删除主节点）</li>
<li><code>--cluster-replicas num</code>：为主节点分配num个从节点</li>
<li><code>--cluster-slave --cluster-master-id id</code>：为主节点分配从节点</li>
</ul>
</li>
<li>每个master可以通过PING命令彼此进行心跳检测</li>
</ul>
</li>
<li>数据读写<ul>
<li><code>hash slot</code>：Redis集群内置了2^14（16384）个哈希槽，需要事先为集群主节点分配<ul>
<li>计算key的哈希值并对16384取模，value保存在余数对应的主节点</li>
<li>只计算key第一个<code>&#123;</code>和第一个<code>&#125;</code>之间的部分，没有才计算整个key</li>
</ul>
</li>
<li>分配哈希槽：<ul>
<li><code>redis-cli --cluster reshard ip:port</code></li>
<li><code>redis-cli --cluster reshard ip:port --cluster-from id1 --cluster-to id2 --cluster-slots num</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Rambo_Yang/article/details/128584227">https://blog.csdn.net/Rambo_Yang/article/details/128584227</a></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li>缓存穿透<ul>
<li>问题：查询的key在缓存和数据库中都不存在，导致每次查询都穿透缓存到达数据库，从而可能压垮数据库</li>
<li>解决：提前存入一定存在的数据到布隆过滤器，后续新增的数据也存入</li>
<li>布隆过滤器：基于位数据（Bit Array）和一组哈希函数构成的数据结构，能快速判断一个元素是否存在于集合中<ul>
<li>位数据初始全为0，key经过哈希函数计算出位数组索引并将对应位置1，查询时对应位全为1表示key存在</li>
</ul>
</li>
</ul>
</li>
<li>缓存雪崩<ul>
<li>问题：当缓存服务器重启或者大量缓存集中在某一个时间段失效，此时大量请求正好要用到失效缓存，导致请求全部到达数据库</li>
<li>解决：多级缓存、限流、过期时间增加随机值保证离散</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>问题：某一热点数据失效，此时大量请求正好要用到失效缓存，导致请求全部到达数据库</li>
<li>解决：多级缓存、限流、使用锁机制保证只有一个请求到达数据库，其他请求直接返回或等待缓存数据</li>
</ul>
</li>
<li>双写一致性<ul>
<li>问题：数据库和缓存数据不一致</li>
<li>解决：先删除缓存，再保证数据库操作成功，最后短暂延迟再删除缓存；MYSQL检测binlog将消息推送到Redis保证缓存更新成功；业务更新后通过MQ发送消息保证消费消息更新到Redis</li>
</ul>
</li>
<li>big key<ul>
<li>问题：大key导致内存分布不均匀、操作大key会阻塞其他请求、增加网络负载</li>
<li>解决：数据拆分</li>
</ul>
</li>
<li>增加命中率：提前缓存热点数据、增加缓存空间的数据量</li>
</ol>
<h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/04/28/ORM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/28/ORM/" class="post-title-link" itemprop="url">ORM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-28 11:56:34" itemprop="dateCreated datePublished" datetime="2024-04-28T11:56:34+08:00">2024-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-04 21:50:27" itemprop="dateModified" datetime="2024-05-04T21:50:27+08:00">2024-05-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ORM（Object-Relational Mapping，对象关系映射）是一种设计技术，通过建立一个中间抽象层，实现面向对象编程语言和关系数据库之间的数据交换，从而将复杂的数据库操作简单化。</p>
<p>常用的开源ORM框架主要有：MyBatis、Hibernate、JPA</p>
<ol>
<li>优点<ul>
<li>提高了开发效率：ORM框架提供了一套规范化的API，开发者只需要以OOP思想开发，不用考虑底层的数据存取问题</li>
<li>简化了数据库操作：ORM框架屏蔽了复杂的SQL操作，开发者只需要关注对象属性的赋值和读取</li>
<li>更加可控性：ORM框架提供了事务管理、查询统计等功能</li>
</ul>
</li>
<li>缺点<ul>
<li>执行效率较低：ORM框架需要在运行时动态构建SQL</li>
<li>代码冗余率高：ORM框架需要编写的配置和代码比较多，需要维护</li>
<li>更新同步困难：ORM框架在运行时无法感知数据库的变化</li>
</ul>
</li>
</ol>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC（Java Database Connectivity）是Java提供的用于与关系型数据库进行交互的标准API，它提供了一种可以使用标准SQL语言与数据库进行交互的规范，遵循规范实现了JDBC接口的API被成为JDBC驱动。</p>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><ol>
<li><code>DriverManager</code>：主要用于注册数据库驱动和获取<code>Connection</code>对象</li>
<li><code>Connection</code>：主要用于获取<code>Statement</code>对象</li>
<li><code>Statement</code>：向数据库发送SQL语句</li>
<li><code>ResultSet</code>：SQL语句的查询结果集</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>加载数据库驱动：使用Class.forName()方法加载特定数据库的JDBC驱动。</li>
<li>建立连接：使用DriverManager.getConnection()方法建立与数据库的连接。</li>
<li>创建Statement：通过Connection对象创建Statement对象，用于执行SQL语句。</li>
<li>执行SQL语句：使用Statement对象执行SQL查询、更新（INSERT、UPDATE、DELETE）、调用存储过程等。</li>
<li>处理结果：如果执行的是查询操作，还需要处理结果集。</li>
<li>关闭资源：在完成数据库操作后，关闭结果集、更新计数和连接对象，释放系统资源。</li>
</ol>
<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>JPA（Java Persistence Application Programming<br>Interface，Java持久层API）通过Java注解或XML来描述对象-关系表的映射，并将运行期的实体对象持久化到数据库中。它是Java对ORM的规范，只提供了一些接口，并未实现完整的ORM功能。</p>
<h3 id="核心接口-配置"><a href="#核心接口-配置" class="headerlink" title="核心接口&#x2F;配置"></a>核心接口&#x2F;配置</h3><ol>
<li>对象-关系表映射注解：@Entity、@Table、@Id、@GeneratedValue、@Column、@OneToMany、@ManyToOne、@ManyToMany</li>
<li><code>persistence.xml</code>：主要是配置数据源和JPA实现方式</li>
<li><code>Persistence</code>：根据配置文件获取<code>EntityManagerFactory</code></li>
<li><code>EntityManagerFactory</code>：用于获取<code>EntityManager</code></li>
<li><code>EntityManager</code>：实体管理器，用于执行查询和持久化操作</li>
<li><code>EntityTransaction</code>：实体事务</li>
</ol>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>Hibernate是一个遵循了JPA规范并对JDBC访问数据库的代码做了封装的ORM框架。</p>
<h3 id="核心接口-配置-1"><a href="#核心接口-配置-1" class="headerlink" title="核心接口&#x2F;配置"></a>核心接口&#x2F;配置</h3><ol>
<li><code>hibernate.cfg.xml</code>：用于配置数据源连接池、事务管理、Hibernate本身的配置信息以及映射文件信息。</li>
<li><code>Configuration</code>：用于读取配置信息并生成<code>SessionFactory</code></li>
<li><code>SessionFactory</code>：负责生成<code>Session</code></li>
<li><code>Session</code>：负责数据库查询和持久化操作和创建<code>Transaction</code>，提供了大量的实体操作，也可以通过创建<code>Query</code>执行SQL、HQL</li>
<li><code>HibernateTemplate</code>：封装<code>SessionFactory</code>和<code>Session</code>，提供了统一操作</li>
<li><code>Transaction</code>：事务管理</li>
<li>配置顺序<ul>
<li>数据源连接池</li>
<li>SessionFactory</li>
<li>HibernateTemplate</li>
<li>TransactionManager</li>
<li>hibernate.cfg.xml</li>
</ul>
</li>
</ol>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>延迟加载&#x2F;懒加载是hibernate为了提高程序执行效率而提供的一种机制，只有真正使用到实体对象时才会去数据库加载。</p>
<p>hibernate通过代理机制实现懒加载：当Hibernate从数据库获取实体对象时，会为实体对象创建一个代理对象，其中所有的属性都是默认值，当真正使用到实体对象时，才会去数据库加载。</p>
<ol>
<li>通过<code>Session.load()</code>方法加载实体，默认采用懒加载</li>
<li>加载一个实体，默认对实体的集合属性采用懒加载</li>
<li>加载一个实体，默认对实体单端关联的实体采用懒加载</li>
<li>通过配置<code>lazy</code>属性设置懒加载：<code>true</code>、<code>false</code>、<code>extra</code></li>
<li>需要注意懒加载机制会在事务提交<code>Session</code>关闭后抛出异常，解决方法主要是延长<code>Session</code>的生命周期</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>一级缓存-&gt;二级缓存-&gt;数据库</p>
<ol>
<li><p>一级缓存：</p>
<ul>
<li>生命周期与<code>Session</code>同步</li>
<li>由hibernate自行开启和管理且不能关闭</li>
<li>通过同一个<code>Session</code>对象执行CURD操作时都会优先与一级缓存同步</li>
<li>事务级别的缓存，当事务提交时会将一级缓存同步到数据库</li>
</ul>
</li>
<li><p>二级缓存：</p>
<ul>
<li>生命周期与<code>SessionFactory</code>同步，所有<code>Session</code>共享，因此是应用级别的全局缓存</li>
<li>默认关闭，需要通过配置手动开启，可以配置第三方缓存插件（EhCache、Redis）</li>
<li>需要为实体类配置指定缓存策略：只读、读写、不严格读写、事务</li>
<li>多个<code>Session</code>同时操作二级缓存可能会出现脏读、数据不一致等问题，可以为实体添加版本号或配置合适的缓存策略</li>
<li>频繁变更实体可能会导致二级缓存性能下降</li>
</ul>
</li>
<li><p>三级缓存&#x2F;查询缓存</p>
<ul>
<li>对普通属性进行缓存，如果修改了关联的表那查询缓存的数据就会失效</li>
<li>需要在开启二级缓存的基础上手动开启从而实现查询时使用缓存</li>
<li>淘汰策略：最近最少使用（LRU）、最少命中（LFU）、先进先出（FIFO）</li>
</ul>
</li>
</ol>
<h3 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h3><ol>
<li>临时态：通过反射、new关键字创建的对象，未被<code>Hibernate</code>的<code>Session</code>管理</li>
<li>持久态：被<code>Hibernate</code>的<code>Session</code>管理的对象</li>
<li>游离态：曾经被<code>Hibernate</code>的<code>Session</code>管理的对象，<code>Session</code>关闭后进入游离态</li>
</ol>
<h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><p>Spring Data JPA是基于Hibernate实现的对JPA规范的再次增强抽象</p>
<ol>
<li>按照注解或XML的方式配置对象-关系表映射</li>
<li>配置：数据源连接池、事务管理器、实体扫描器、hibernate配置</li>
<li>持久层接口只需要继承*Repository接口即可，也可以按照一定规则声明持久层接口或者使用执行SQL的注解<ul>
<li>CrudRepository、JpaRepository、PagingAndSortingRepository</li>
<li>JpaSpecificationExecutor：用于实现复杂的动态SQL</li>
<li>findBy（关键字）+属性名称（首字母大写）+ 查询条件（首字母大写）</li>
<li>@Query、@Modifying</li>
</ul>
</li>
</ol>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>MyBatis是一个封装了JDBC的半自动ORM开源框架，支持自定义SQL、存储过程、高级映射和事务等功能。</p>
<ol>
<li>简单易用：API非常简单，与spring的整合也很方便</li>
<li>高灵活性：允许开发者自定义SQL语句，满足各种复杂的查询和数据操作需求</li>
<li>映射关系自由：不强制要求实体类和数据库表之间的映射关系，开发者可以灵活选择使用注解或XML配置文件来管理映射关系</li>
<li>易于扩展：提供插件机制，方便添加自定义功能</li>
<li>事务管理：支持默认的SqlSession事务、spring事务、全局事务三种管理方式</li>
</ol>
<h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><ol>
<li><code>SQL Mapper</code>：负责定义SQL语句，并将SQL语句映射成为Java对象或Map集合的结果</li>
<li>MyBatis核心：提供执行SQL语句的底层逻辑，包括管理SQL会话、数据源连接池和事务等资源</li>
<li>数据源连接池：为SQL执行器提供数据库连接</li>
<li>MyBatis插件：允许用户在运行过程中对MyBatis核心进行扩展</li>
</ol>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ol>
<li><code>mybatis-config.xml</code>：数据源连接池、事务管理等全局配置以及映射配置和插件配置信息</li>
<li><code>SqlSessionFactoryBuilder</code>：读取配置文件，创建<code>SqlSessionFactory</code></li>
<li><code>SqlSessionFactory</code>：创建<code>SqlSession</code>，并维护数据源连接池和缓存等资源</li>
<li><code>SqlSession</code>：用于执行SQL语句和<code>Mapper Interface</code>定义的接口</li>
<li><code>Mapper Interface</code>：定义SQL语句调用的接口，与<code>Mapper XML</code>对应</li>
<li><code>Mapper XML</code>：定义了映射关系的配置信息和SQL语句的具体实现<ul>
<li>通过<code>namespace</code>和<code>Mapper Interface</code>匹配</li>
<li>通过<code>resultMap</code>配置对象-关系表的映射</li>
<li>通过<code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code>标签定义SQL语句，<code>id</code>属性匹配接口</li>
</ul>
</li>
</ol>
<h3 id="延迟加载-1"><a href="#延迟加载-1" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>MyBatis基于代理机制提供延迟加载&#x2F;懒加载，在使用到实体关联的其他实体对象时才去真正加载数据，从而减少内存浪费和减轻系统负担</p>
<ol>
<li>延迟加载功能默认关闭，需要在配置中手动开启<code>lazyLoadingEnabled</code></li>
<li>在结果映射中为关联的对象或集合设置延迟加载<ul>
<li>关联对象：<code>association</code>标签配置<code>fetchType=&quot;lazy&quot;</code></li>
<li>关联集合：<code>collection</code>标签配置<code>fetchType=&quot;lazy&quot;</code></li>
</ul>
</li>
</ol>
<p>需要注意懒加载机制在事务环境中可能会出现一些问题。</p>
<h3 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h3><p>二级缓存-&gt;一级缓存-&gt;数据库</p>
<ol>
<li><p>一级缓存：</p>
<ul>
<li>生命周期与<code>SqlSession</code>同步</li>
<li>由MyBatis自行开启和管理且不能关闭</li>
<li>通过同一个<code>SqlSession</code>对象执行查询操作时都会优先与一级缓存同步</li>
<li>事务级别的缓存，当事务提交时会将一级缓存同步到数据库</li>
</ul>
</li>
<li><p>二级缓存：</p>
<ul>
<li>生命周期与<code>SqlSessionFactory</code>同步，同一个<code>namespace</code>下所有的<code>SqlSession</code>共享，因此不是应用级别的全局缓存</li>
<li>默认关闭，需要通过配置手动开启，可以配置第三方缓存插件（EhCache、Redis）</li>
<li>实体类必须可序列化且映射文件必须配置<code>&lt;cache&gt;</code>标签和<code>useCache</code>属性</li>
<li>不同<code>namespace</code>下的多个<code>SqlSession</code>同时操作二级缓存可能会出现脏读、数据不一致等问题</li>
<li>频繁执行更新SQL可能会导致二级缓存性能下降</li>
</ul>
</li>
</ol>
<h3 id="SQL语句类型"><a href="#SQL语句类型" class="headerlink" title="SQL语句类型"></a>SQL语句类型</h3><p>映射文件中定义的SQL语句有三种处理类型，可以通过<code>statementType</code>属性配置</p>
<ol>
<li><code>STATEMENT</code>：直接操作SQL，不进行预编译，使用$获取和拼接参数</li>
<li><code>PREPARED</code>：默认，使用#获取和拼接参数，对参数预处理，对SQL预编译</li>
<li><code>CALLABLE</code>：用于执行存储过程，<code>&#123; call PROCEDURE(#(param,mode=IN))&#125;</code></li>
</ol>
<h3 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h3><p>插件机制基于<code>SqlSession</code>内部的四个组件，通过拦截器链和动态代理组织多个拦截器（插件）改变或增强默认行为，插件本质上就是拦截器生成的代理对象。</p>
<p>在配置文件中配置了插件后，<code>MyBatis</code>启动后会通过<code>Configration</code><br>会读取所有的插件并构建拦截器链</p>
<p>当<code>SqlSession</code>执行CRUD操作时，内部的四个组件会依次调用拦截器链并返回拦截器的代理对象，最终原生的四个组件都可以被替换成代理对象并完成插件的功能。</p>
<ol>
<li><code>Executor</code>：执行器，用于执行SQL</li>
<li><code>ParameterHandler</code>：参数处理</li>
<li><code>ResultSetHandler</code>：结果集处理</li>
<li><code>StatementHandler</code>：Sql语法构建处理</li>
<li><code>Interceptor</code>：插件基类<ul>
<li><code>intercept()</code>：实现拦截逻辑，需要显示调用<code>proceed()</code>推进拦截器链</li>
<li><code>plugin()</code>：通过JDK动态代理生成代理对象</li>
<li><code>setProperties()</code>：设置代理对象的参数</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/04/26/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/26/SpringBoot/" class="post-title-link" itemprop="url">SPRING BOOT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-26 18:08:05" itemprop="dateCreated datePublished" datetime="2024-04-26T18:08:05+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-04 21:35:48" itemprop="dateModified" datetime="2024-05-04T21:35:48+08:00">2024-05-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>当使用Spring框架组合其他框架构建一个应用程序时，组合这些框架之间的配置往往复杂费时且一次性，因此出现了SpringBoot框架。</p>
<p>Spring Boot的设计目的是为了简化新Spring应用的初始搭建，它默认使用了特定的方式来进行配置，从而使开发者不用再定义模板化的配置，而是专注于业务开发。</p>
<h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><p>约定优于配置（convention over configuration）也称作按约定编程，是一种软件设计范式，通过减少开发者做决定的数量，获得简单的好处而又不失灵活性。</p>
<p>Spring Boot以最简配置为核心思想，提供了spring本身和主流第三方框架的默认配置，在组合这些框架时只需要引入对应的依赖，定义极少配置甚至不用配置即可使用。</p>
<ol>
<li>如果没有自定义配置，则采用约定的默认配置</li>
<li>如果有特殊需求不符合约定的默认配置，也可以自定义配置</li>
</ol>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>自动装配是指Spring Boot通过分析项目依赖中约定的默认配置和自定义配置，自动装配Spring应用程序所需的组件，而无需手动配置大量的XML配置文件或Java代码。</p>
<p>自动装配功能通过@SpringBootApplication注解启动，自动从约定文件中读取Spring Boot提供的JavaConfig配置类并注册成Bean。</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>注解@SpringBootApplication &#x3D; @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p><code>@SpringBootConfiguration</code>注解内部使用了<code>@Configuration</code>注解，并使用<code>@AliasFor</code>注解覆盖了<code>@Configuration</code>注解的<code>proxyBeanMethods</code><br>属性，可以认为<code>@SpringBootConfiguration</code>注解继承了<code>@Configuration</code>注解并<code>Override</code>了<code>proxyBeanMethods</code>属性。</p>
<p>标注了<code>@Configuration</code>注解的类是JavaConfig形式的配置类，SpringIOC容器会把配置类下所有标注了<code>@Bean</code>注解的方法返回的对象注册成Bean。</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><code>@ComponentScan</code>的功能是自动扫描符合条件的组件，并加载到SpringIOC容器，可以通过<code>basePackages</code>等属性来细粒度的定制自动扫描的范围，如果不指定，则默认扫描同级路径及子路径。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><code>@EnableAutoConfiguration</code>注解是Spring Boot实现自动装配的核心，其工作流程按照顺序依次是：</p>
<ol>
<li>启动类的复合注解<code>@SpringBootApplication</code>内置<code>@EnableAutoConfiguration</code>注解</li>
<li><code>@EnableAutoConfiguration</code>注解通过<code>@Import</code>注解导入<code>AutoConfigurationImportSelector</code>类</li>
<li><code>AutoConfigurationImportSelector</code>类实现的接口之一<code>DeferredImportSelector</code>通过内置接口<code>Group</code>的<code>process()</code>和<code>selectImports()</code><br>覆盖了<code>ImportSelector</code>接口的<code>selectImports()</code></li>
<li><code>process()</code>调用<code>getAutoConfigurationEntry()</code></li>
<li><code>getAutoConfigurationEntry()</code>调用<code>getCandidateConfigurations()</code></li>
<li><code>getCandidateConfigurations()</code>获取约定文件下的配置类全限定名</li>
<li><code>selectImports()</code>获取所有配置类并去重和移除不需要的配置类</li>
</ol>
<p>**<code>@Import()</code>**：用于在配置类中导入其他配置类或者普通的Java类</p>
<ul>
<li>导入实现了<code>ImportSelector</code>接口的类：不注入该类型的对象，调用<code>selectImports()</code>方法，将返回的数据注入到容器中</li>
<li>导入实现了<code>ImportBeanDefinitionRegistrar</code>接口的类：不注入该类型的对象，调用<code>registerBeanDefinitions()</code>方法，通过注册器注入</li>
<li>导入其他普通类型：直接注入该类型的对象</li>
</ul>
<p>**<code>AutoConfigurationImportSelector</code>*<em>：实现了SpringIOC容器初始化和Bean初始化的</em>Aware扩展接口和<code>DeferredImportSelector</code>延迟导入选择器接口</p>
<ul>
<li><code>DeferredImportSelector</code>：实现了<code>ImportSelector</code>接口并内置了一个Group接口，包含了要导入的配置类的元注解信息和类名的Group.Entry</li>
<li><code>ImportSelector</code>：<code>selectImports()</code>找到并返回需要自动配置的配置类的全限定名</li>
<li><code>getImportGroup()</code>：<code>DeferredImportSelector</code>接口中覆盖<code>ImportSelector</code>接口的<code>selectImports()</code>的方法</li>
<li><code>getAutoConfigurationEntry()</code>：从约定的<code>META-INF/spring.factories</code>文件(3.0之前)或者<code>META-INF/spring/*.imports</code>文件（3.0之后）中加载配置类</li>
</ul>
<h2 id="starter组件"><a href="#starter组件" class="headerlink" title="starter组件"></a>starter组件</h2><p>Spring Boot Starter是Spring Boot定义的一种规范，用于简化Spring应用的依赖管理和配置。</p>
<p>在Spring项目中，导入或自定义一个中间件的功能主要有三步：</p>
<ol>
<li>导入依赖，定义需要的配置类</li>
<li>将配置类交给SpringIOC容器管理</li>
<li>通过@Resource、@Autowired、ApplicationContext.getBean()获取Bean实例并使用</li>
</ol>
<p>其中前两个步骤在每一个spring项目中都需要做复杂费时且一次性的配置，因此可以通过遵循Spring Boot Starter规范一次性定义好所有的配置并打包成Starter组件，以后项目中需要便可以拿来即用。</p>
<h3 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h3><ol>
<li>创建一个spring工程，导入<code>spring-boot-starter</code>和<code>spring-boot-configuration-processor</code>基础依赖</li>
<li>按照JavaConfig形式定义好参数实体和配置类<ul>
<li>@ConfigurationProperties：从application.yml文件中读取配置项信息并映射到参数实体的属性上</li>
<li>@EnableConfigurationProperties：使@ConfigurationProperties生效</li>
<li>@Configuration&#x2F;@Component：标注配置类</li>
<li>@ConditionalOnProperty：如果有指定的配置，条件生效</li>
<li>@ConditionalOnBean：如果有指定的Bean，条件生效</li>
<li>@ConditionalOnMissingBean：如果没有指定的Bean，条件生效</li>
<li>@ConditionalOnMissingClass：如果没有指定的Class，条件生效</li>
<li>@ConditionalOnWebApplication：在Web环境中条件生效</li>
<li>@ConditionalOnExpression：根据表达式判断条件是否生效</li>
</ul>
</li>
<li>在<code>resources</code>目录下创建<code>META-INF/spring.factories</code>文件，暴露自定义的自动装配配置类<ul>
<li>在同级目录下创建<code>spring-configuration-metadata.json</code>文件，用于描述参数实体的属性的元数据信息，或者在属性上使用Javadoc来描述</li>
</ul>
</li>
<li>打包，其他项目引入starter依赖即可</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/04/19/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/19/Spring/" class="post-title-link" itemprop="url">SPRING</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-19 21:37:44" itemprop="dateCreated datePublished" datetime="2024-04-19T21:37:44+08:00">2024-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-04 18:27:05" itemprop="dateModified" datetime="2024-05-04T18:27:05+08:00">2024-05-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring是一个轻量级的开源框架，以IOC和AOP为内核，它提供了展示层、持久层、业务层事物管理等众多企业级应用技术，并且可以整合众多主流的开源框架和类库，能简化开发、方便解耦和测试。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Spring框架提供了大概20个模块，按照功能可划分为五个大类：</p>
<ol>
<li><code>Core Container</code>：<code>Beans</code> <code>Core</code> <code>Context</code> <code>SpEL</code></li>
<li><code>AOP</code>：<code>AOP</code> <code>Aspects</code> <code>Instrumentation</code> <code>Messaging</code></li>
<li><code>Data Access/Integration</code>：<code>JDBC</code> <code>ORM</code> <code>OXM</code> <code>JMS</code> <code>Transactions</code></li>
<li><code>Web</code>： <code>WebSocket</code> <code>Servlet</code> <code>Web</code> <code>Portlet</code></li>
<li><code>Test</code></li>
</ol>
<h2 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h2><ol>
<li>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。</li>
<li>bean是由Spring IoC容器自动完成实例化、组装和管理的对象。</li>
<li>根据XML配置文件或者注解标注一个类可以告知Spring IOC容器这是一个Bean。</li>
</ol>
<h3 id="定义Bean"><a href="#定义Bean" class="headerlink" title="定义Bean"></a>定义Bean</h3><ol>
<li>XML配置文件</li>
<li>注解：@Component、@ComponentScan、@Configuration、@Bean、@DependOn等</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>可以在XML配置文件中通过scope属性或者@Scope注解声明bean的作用域。</p>
<ol>
<li><code>singleton</code><br>：默认值，单例作用域，在容器中仅存在一个共享的单例bean实例，单例bean在容器创建时就会实例化一个bean对象，但也可以通过XML配置文件的lazy-init属性或者@Lazy注解延迟到第一次使用bean的时候再初始化；</li>
<li><code>prototype</code>：原型作用域，每次获取都会返回一个新的bean实例，原型类型的bean在容器创建时不会实例化，而是在使用Bean的时候才创建一个对象；</li>
<li><code>request</code>：HTTP Request作用域，每一次HTTP请求都会产生一个新的bean实例，该实例只在当前请求内有效，请求结束后就会销毁；</li>
<li><code>session</code>：HTTP Session作用域，在同一个HTTP Session范围内只会生成一个bean实例，回话结束后实例就会销毁；</li>
<li><code>application</code>：表示在一次ServletContext内，创建bean的一个实例，并且该实例仅在当前ServletContext内有效。</li>
<li><code>websocket</code>：表示在一次WebSocket session内，创建bean的一个实例，并且该实例仅在当前WebSocket session内有效。</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Spring Bean的生命周期是指Bean在Spring容器中从创建到销毁的整个管理过程。</p>
<ol>
<li>实例化：容器在启动后，会通过XML配置文件或者注解找到定义成Bean的类，这些类的元数据被封装在实现了BeanDefinition接口的类中，然后创建一个bean实例；<ul>
<li>构造方法：将bean的无参构造方法通过反射创建实例</li>
<li>静态工厂：在对象工厂声明创建bean的静态方法，实例化时指定工厂类和工厂方法</li>
<li>实例工厂：<ul>
<li>在对象工厂声明创建bean的非静态方法，实例化时指定工厂bean和工厂方法</li>
<li>对象工厂类实现FactoryBean接口</li>
</ul>
</li>
</ul>
</li>
<li>注入属性：如果涉及属性的设置则通过set方法注入属性的值</li>
<li>初始化：<ul>
<li>如果实现了*Aware接口则调用接口实现的方法；</li>
<li>如果使用了@PostConstruct注解则执行指定的方法</li>
<li>如果实现了InitializingBean接口则执行指定afterPropertiesSet方法；</li>
<li>如果配置文件指定了init-method则执行指定的方法；<ul>
<li>至此就完成初始化工作，后续可以通过后置处理器做一些自定义扩展，比如创建代理</li>
</ul>
</li>
<li>如果实现了BeanPostProcessor接口则会在初始化前后处理；</li>
<li>如果实现了Destruction接口则会注册销毁bean的回调方法；</li>
</ul>
</li>
<li>调用：通过@Autowired注解或者ApplicationContext的getBean()获取对象实例并且使用；</li>
<li>销毁：关闭应用时spring调用ApplicationContext的close()来关闭容器则会销毁Bean；<ul>
<li>如果实现了Destruction接口则会调用回调方法；</li>
<li>如果使用了@PreDestroy注解则执行指定的方法；</li>
<li>如果实现了DisposableBean接口则调用destroy()的方法；</li>
<li>如果配置文件指定了destroy-method则执行指定的销毁方法；</li>
</ul>
</li>
</ol>
<h3 id="循环依赖问题-三级缓存机制"><a href="#循环依赖问题-三级缓存机制" class="headerlink" title="循环依赖问题&#x2F;三级缓存机制"></a>循环依赖问题&#x2F;三级缓存机制</h3><ol>
<li><p>循环依赖：在Beans的创建过程中，可能出现多个Bean相互依赖的关系，Spring IOC容器在创建A时，发现需要注入B转而去创建B，但创建B时又发现需要注入A转而去创建A，因此出现了死循环。</p>
</li>
<li><p>三级缓存：Spring通过引入三级缓存机制来解决循环依赖问题：</p>
<ul>
<li>一级缓存（singletonObjects）保存完成初始化的bean</li>
<li>二级缓存（earlySingletonObjects）保存已经实例化但未完成初始化的bean</li>
<li>三级缓存（singletonFactories）保存创建bean的ObjectFactory</li>
</ul>
</li>
</ol>
<p>假设beanA和beanC相互依赖：</p>
<ol>
<li><p>当获取beanA时，会依次从一级缓存、二级缓存、三级缓存、父类对象工厂中获取实例，如果获取不到则根据BeanDefinition和反射创建实例，并把beanA的ObjectFactory对象存入三级缓存<br>为beanA注入属性时发现需要注入beanC，于是去获取beanC</p>
</li>
<li><p>当获取beanC时，会依次从一级缓存、二级缓存、三级缓存、父类对象工厂中获取实例，如果获取不到则根据BeanDefinition和反射创建实例，并把beanC的ObjectFactory对象存入三级缓存<br>为beanC注入属性时发现需要注入beanA，于是去获取beanA</p>
</li>
<li><p>依次从一级缓存、二级缓存、三级缓存、父类对象工厂中获取实例beanA的实例，这时三级缓存中存在beanA的ObjectFactory对象，于是通过getObject方法获取beanA的实例或者代理实例<br>然后把实例存入二级缓存，并移除beanA的三级缓存</p>
</li>
<li><p>beanC成功注入beanA，完成初始化操作和后置处理，然后把beanC的实例或者代理实例保存到一级缓存，并移除三级缓存</p>
</li>
<li><p>beanA成功注入beanC，完成初始化操作和后置处理时，发现beanA在二级缓存，于是取出二级缓存并替换掉，最后移除二级缓存并保存到一级缓存</p>
</li>
</ol>
<p>三级缓存机制的理论依据基于Java的引用传递，当获取对象的引用时可以让对象的属性延迟设置，因此三级缓存只能解决属性注入和setter注入的循环依赖，无法解决有参构造方法注入的循环依赖。</p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC（Inversion of Control，控制反转）是一种设计思想，简单来说就是把一个复杂的系统分解成多个相互合作、相互依赖的对象，这些对象通过第三方来封装，从而降低了对象之间的耦合度和解决问题的复杂度，而且可以灵活的被重用和扩展。<br>在spring中，这个第三方就是Spring IOC容器，而容器的底层则是对象工厂。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>DI（Dependency Injection，依赖注入）是指由IoC容器在运行期间，动态的将某种依赖关系注入到对象之中。</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>BeanDefinition是定义Bean的元数据信息的接口，包含了bean的全限定名、构造方法、属性、作用域、懒加载等信息，spring通过BeanDefinitionReader找到并读取所有定义成bean的类，然后将其转换成BeanDefinition对象，最后根据BeanDefinition来创建bean。</p>
<h3 id="IOC流程"><a href="#IOC流程" class="headerlink" title="IOC流程"></a>IOC流程</h3><p>当启动spring应用时，IOC容器也会一起启动，它的启动流程可以归纳为三个步骤：</p>
<ol>
<li>初始化容器，把内置的BeanPostProcessor的BeanDefinition注册到容器；</li>
<li>获取所有配置类的BeanDefinition并注册到容器；</li>
<li>调用refresh()方法刷新容器。<ul>
<li><code>prepareRefresh</code>：刷新前的预处理，设置当前时间和容器状态</li>
<li><code>obtainFreshBeanFactory</code>：创建BeanFactory实例</li>
<li><code>prepareBeanFactory</code>：设置BeanFactory，比如当前上下文的类加载器、系统环境和系统属性</li>
<li><code>postProcessBeanFactory</code>：注册内置后置处理</li>
<li><code>invokeBeanFactoryPostProcessors</code>：调用内置后置处理</li>
<li><code>registerBeanPostProcessors</code>：注册其他后置处理器</li>
<li><code>initMessageSource</code>：初始化消息资源组件，主要作用是从配置文件读取国际化配置</li>
<li><code>initApplicationEventMulticaster</code>：初始化事件派发器</li>
<li><code>registerListeners</code>：注册监听器，并把监听器添加到事件派发器</li>
<li><code>finishBeanFactoryInitialization</code>：实例化所有非懒加载非抽象类的单例bean并放入IOC容器</li>
<li><code>finishRefresh</code>：完成容器初始化后的一些操作，如清除资源缓存、发布容器刷新完成事件</li>
</ul>
</li>
</ol>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>IOC容器的基本实现，是Spring内部使用的接口，不提供给开发人员使用，在加载配置文件时不会创建对象，在获取对象时才采取创建对象。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>BeanFactory接口的子接口，提供更多强大的功能，一般由开发人员使用。接口提供了bean基础性操作同时，扩展了国际化等功能。ApplicationContext接口在加载配置文件时候就会创建配置文件中的对象，存放IOC容器当中。</p>
<h2 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h2><p>SpEL（Spring Expression Language，表达式语言）能够在运行时构建复杂表达式, 存取对象属性、调用对象方法等</p>
<ol>
<li>所有的SpEL都支持XML和Annotation两种方式，使用的格式均为：<code>#&#123;SpEL expression&#125;</code></li>
<li>通过<code>new SpelExpressionParser()</code>创建解析器</li>
</ol>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Program，面向切面编程）是通过预编译和运行时动态代理来实现统一维护程序功能的技术思想，是OOP（Object Oriented Programming，面向对象）思想的延伸。</p>
<p>在OOP中以类&#x2F;class作为基本单元，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的纵向逻辑划分；在AOP中以切面&#x2F;Aspect作为基本单元，针对业务处理过程中的重复代码进行提取，并通过代理模式，在不改变原有代码逻辑的基础上，动态地将重复代码或者增强处理切入到指定的位置。</p>
<p>在Spring中，AOP由Spring AOP框架实现。</p>
<h3 id="Spring-AOP组成"><a href="#Spring-AOP组成" class="headerlink" title="Spring AOP组成"></a>Spring AOP组成</h3><p>AOP的基本单元是Aspect，它由JoinPoint（连接点）、PointCut（切点）和Advice（通知处理）三个部分组成。</p>
<ol>
<li><code>Aspect</code>：切面定义了一个AOP的功能。</li>
<li><code>JoinPoint</code>：连接点是程序运行过程中可识别的点（调用方法、抛出异常、修改字段等），这些点可以用来作为AOP切入点将切面织入指定位置，而连接点中包含了切入点的对象、方法、属性等上下文信息。</li>
<li><code>PointCut</code>：切点的作用是提供一组规则来匹配连接点，并给所有满足规则的连接点添加通知处理</li>
<li><code>Advice</code>：通知处理是AOP实际完成增强处理的部分，并且可以在指定时机执行指定的处理。<ul>
<li><code>Before</code>：前置处理</li>
<li><code>After</code>：后置处理</li>
<li><code>Around</code>：环绕处理</li>
<li><code>AfterReturning</code>：后置返回通知</li>
<li><code>AfterThrowing</code>：异常处理</li>
</ul>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Spring AOP通过动态代理+拦截器链的方式实现。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ol>
<li>JDK动态代理：基于反射和实现接口<ul>
<li>Proxy.newProxyInstance()创建被代理类的代理类</li>
<li>代理类实现InvocationHandler接口的invoke()方法，通过反射调用被代理类的目标方法</li>
</ul>
</li>
<li>CGLIB动态代理：基于字节码和子类继承<ul>
<li>Enhancer创建被代理类的代理类</li>
<li>代理类实现MethodInterceptor接口的intercept()方法，通过父类方法调用被代理类的目标方法</li>
</ul>
</li>
<li>非提前生成代理：初始化后<ul>
<li>在bean完成初始化后，会执行所有的BeanPostProcessor后置处理，</li>
<li>其中AnnotationAwareAspectJAutoProxyCreator后置处理中wrapIfNecessary()<br>方法实现了aop动态代理，能返回bean的实例或者代理类实例并替换原来的bean</li>
</ul>
</li>
<li>提前生成代理：注入属性时<ul>
<li>提前生成代理主要是为了解决循环依赖问题</li>
<li>当beanC获取beanA时 通过getSingleton()方法从三级缓存中获取beanA的ObjectFactory对象</li>
<li>ObjectFactory对象的getObject()方法是执行的getEarlyBeanReference()方法</li>
<li>这个方法会调用所有实现了SmartInstantiationAwareBeanPostProcessor接口的后置处理器的getEarlyBeanReference()<br>方法，AnnotationAwareAspectJAutoProxyCreator后置处理器实现了SmartInstantiationAwareBeanPostProcessor接口，它的getEarlyBeanReference()<br>方法 中调用的wrapIfNecessary()<br>方法实现了aop动态代理，能返回bean的实例或者代理类实例并替换原来的bean</li>
</ul>
</li>
<li>wrapIfNecessary()<ul>
<li>如果传入的对象已经处理过、已经创建了代理类、是spring内置的bean、应该忽略，则直接返回</li>
<li>任意一项不满足，则创建代理类工厂，创建并返回代理类</li>
</ul>
</li>
</ol>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><ol>
<li>在<code>Advice</code>中有多个增强处理方法，每个方法都有一个拦截器</li>
<li>在为切面类创建bean时，需要通过代理工厂为其创建代理类</li>
<li>代理工厂中封装了Advice的所有方法的advisors</li>
<li>在创建代理类时，会按照顺序创建advisors的拦截器链</li>
<li>不同切面默认按照字典排序，也可以使用<code>@Order</code>注解或实现<code>Order</code>接口，数值越小优先级越高</li>
<li>同一切面多个相同<code>Advice</code>方法按照字典排序，不同<code>Advice</code>方法按照固定顺序<ul>
<li>环绕通知前置处理-&gt;前置处理-&gt;代理方法-&gt;后置处理-&gt;环绕通知后置处理-&gt;返回通知处理&#x2F;异常通知处理</li>
</ul>
</li>
</ol>
<h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>事务是关系型数据库的重要组成，用来确保应用程序数据的完整性和一致性。</p>
<p>在spring中，事务是访问和更新数据库中各种数据项的一个程序执行单元，当在数据库中更改数据成功时，在事务中更改的数据便会提交并且不再改变，否则事务就取消或者回滚，让更改的数据无效。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务具有四种特性：原子性、一致性、隔离型、持久性，即ACID特性</p>
<ol>
<li>原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。</li>
<li>一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。</li>
<li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。</li>
<li>持久性（Durability）：一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</li>
</ol>
<h3 id="隔离性问题"><a href="#隔离性问题" class="headerlink" title="隔离性问题"></a>隔离性问题</h3><p>事务的隔离性定义了并发事务互不干扰，但在不同的隔离级别下，仍有可能出现一些问题：</p>
<ol>
<li>脏读：事务A读取事务B未提交的数据后，事务B回滚数据，导致事务A读到的数据无效。</li>
<li>不可重复读：事务A多次查询同一数据，在查询间隔内事务B修改了数据，导致事务A得到了不同结果，</li>
<li>幻读：事务A多次范围查询同一组数据集，在查询间隔内事务B修改了数据集，导致事务A得到的数据集不一样。如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。</li>
</ol>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol>
<li>读未提交：最低的隔离级别<ul>
<li>当前事务可以看到其他事务未提交的修改</li>
<li>可能出现脏读、不可重复读和幻读</li>
</ul>
</li>
<li>读已提交：Oracle默认<ul>
<li>当前事务可以看到其他事务已提交的修改</li>
<li>可能出现不可重复读和幻读</li>
</ul>
</li>
<li>可重复读：Mysql默认<ul>
<li>一个事务多次查询同一数据能得到一致的结果，其他事务对同一数据的修改不会造成影响</li>
<li>可能出现幻读</li>
</ul>
</li>
<li>串行化：最高的隔离级别<ul>
<li>所有事务按照次序依次执行</li>
</ul>
</li>
</ol>
<p>不同的事务隔离级别提供了不同程度的隔离策略，以满足不同应用场景对于一致性和性能的需求，在选择事务隔离级别时，需要在数据一致性和系统性能之间进行权衡。</p>
<h3 id="spring事务支持"><a href="#spring事务支持" class="headerlink" title="spring事务支持"></a>spring事务支持</h3><ol>
<li>编程式：编程式事务管理是通过在业务代码中嵌入事务管理代码的方式实现的事务管理，灵活性高可以将事务精确到代码块级别，但难以维护。</li>
<li>声明式：基于AOP技术实现的事务管理，可以将事务管理和业务代码分开，并同一维护，只能控制方法级别的事务。<ul>
<li>基于XML配置</li>
<li>基于注解</li>
</ul>
</li>
</ol>
<h3 id="spring事务管理器"><a href="#spring事务管理器" class="headerlink" title="spring事务管理器"></a>spring事务管理器</h3><p>Spring基于AOP提供了多种事务管理器，其中包含了事务传播行为、隔离级别、只读和超时等属性，这些属性提供了事务应用的方法和描述策略，用于事务管理。</p>
<ol>
<li><code>PlatformTransactionManager</code>接口：用于管理事务<ul>
<li><code>getTransaction()</code>：获取事务状态信息</li>
<li><code>commit()</code>：提交事务</li>
<li><code>rollback()</code>：回滚事务</li>
</ul>
</li>
<li><code>TransactionDefinition</code>接口：用于描述事务属性<ul>
<li><code>getPropagationBehavior()</code>：事务传播行为<ul>
<li><code>PROPAGATION_REQUIRED</code>：支持当前事务，如果没有事务则创建新事务。</li>
<li><code>PROPAGATION_SUPPORTS</code>：支持当前事务，如果没有事务则以非事务方式执行。</li>
<li><code>PROPAGATION_MANDATORY</code>：支持当前事务，如果没有事务则抛出异常。</li>
<li><code>PROPAGATION_REQUIRES_NEW</code>：创建新事务，如果有当前事务，则将当前事务挂起。</li>
<li><code>PROPAGATION_NOT_SUPPORTED</code>：以非事务方式执行，如果有当前事务，则将当前事务挂起。</li>
<li><code>PROPAGATION_NEVER</code>：以非事务方式执行，如果存在事务则抛出异常。</li>
<li><code>PROPAGATION_NESTED</code><br>：如果当前存在事务，则执行一个嵌套事务，如果当前没有事务，则等同于REQUIRED。嵌套事务中，主事务包含多个子事务，每个子事务都可以单独提交和回滚。如果主事务失败，所有子事务都会回滚。</li>
</ul>
</li>
<li><code>getIsolationLevel()</code>：事务隔离级别<ul>
<li><code>ISOLATION_DEFAULT</code>：使用数据库默认级别</li>
<li><code>ISOLATION_READ_UNCOMMITTED</code>：读未提交</li>
<li><code>ISOLATION_READ_COMMITTED</code>：读已提交</li>
<li><code>ISOLATION_REPEATABLE_READ</code>：可重复读</li>
<li><code>ISOLATION_SERIALIZABLE</code>：串行化</li>
</ul>
</li>
<li><code>getTimeout()</code>：超时时机</li>
<li><code>isReadOnly()</code>：事务只读</li>
<li><code>getName()</code>：事务名称</li>
</ul>
</li>
<li><code>TransactionStatus</code>接口：用于控制和描述事务状态<ul>
<li><code>isNewTransaction()</code>：是否是新事务</li>
<li><code>hasSavepoint()</code>：是否有保存点</li>
<li><code>setRollbackOnly()</code>：设置回滚</li>
<li><code>isRollbackOnly()</code>：是否回滚</li>
<li><code>flush()</code>：刷新事务</li>
<li><code>isCompleted()</code>：事务是否完成</li>
</ul>
</li>
</ol>
<h3 id="Spring事务失效问题"><a href="#Spring事务失效问题" class="headerlink" title="Spring事务失效问题"></a>Spring事务失效问题</h3><p>Spring事务基于AOP动态代理和数据库本身。</p>
<ol>
<li>数据库不支持事务</li>
<li>多次持久化操作使用了不同的数据库连接</li>
<li>事务方法所在的类被final修饰导致不能生成代理</li>
<li>事务方法所在的类没有被SpringIOC容器管理</li>
<li>事务方法私有</li>
<li>事务方法异常不匹配，默认只处理运行时异常</li>
<li>类内部事务方法相互调用</li>
<li>事务传播机制不合理</li>
<li>多线程处理事务</li>
</ol>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC是Spring Framework提供的Web组件，是一个实现了MVC设计思想的框架，可以提供前端路由映射、视图解析等功能。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC是一种把软件划分成模型、视图、控制器三个部分的软件设计思想</p>
<ol>
<li>模型（model）：也就是javabean，用于业务逻辑处理、数据访问和存储</li>
<li>视图（view）：也就是html和jsp页面，用于展示数据和用户交互</li>
<li>控制器（controller）：也就是servlet和controller，用于接收和响应请求</li>
</ol>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是接收和响应请求的中间层，可以生成动态的Web内容以及交互式地浏览和生成数据。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>SpringMVC的实现原理由其核心组件按照一定的工作流程实现。</p>
<ol>
<li><code>DispatcherServlet</code>：负责调度其他组件</li>
<li><code>Handler</code>：处理器，完成具体的业务逻辑，相当于Servlet</li>
<li><code>HandlerMapping</code>：处理器映射器，映射不同的请求到不同的Handler</li>
<li><code>HandlerInterceptor</code>：处理器拦截器，可以在处理器前后做拦截处理</li>
<li><code>HandlerExecutionChain</code>：处理器执行链，由<code>Handler</code>和<code>HandlerInterceptor</code>组成</li>
<li><code>HandlerAdapter</code>：处理器适配器，完成数据验证、数据类型转换、数据封装等操作后执行<code>Handler</code></li>
<li><code>ModelAndView</code>：<code>Handler</code>的执行结果，封装了模型数据和视图信息</li>
<li><code>ViewResolver</code>：视图解析器，把逻辑视图解析成实际视图</li>
</ol>
<p>当<code>DispatcherServlet</code>接收到客户端请求后，首先根据请求信息调用<code>HandlerMapping</code>解析出包含了<code>Handler</code>和<code>HandlerInterceptor</code>的<code>HandlerExecutionChain</code><br>，然后由<code>HandlerAdapter</code>完成参数解析并根据<code>Handler</code>执行业务处理，处理完成后得到<code>ModelAndView</code>，再由<code>ViewResolver</code>解析出实际的<code>View</code>并返回给客户端</p>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>WebSocket是HTML5定义的一种新协议，基于TCP实现了浏览器与服务器的全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。</p>
<h3 id="即时通信"><a href="#即时通信" class="headerlink" title="即时通信"></a>即时通信</h3><ol>
<li>短轮询：客户端间隔较短的时间向服务端发送请求并立即返回响应</li>
<li>长轮询：客户端间隔较短的时间向服务端发送请求，服务端持续等待到满足一定条件后返回响应，或者等待超时断开连接</li>
<li>SSE长连接：客户端向服务端发送请求，服务端不关闭连接，而是通过SSE持续向客户端发送数据，需要注意超时时间、servlet和filter开启异步、nginx代理关闭缓存和缓冲区</li>
<li>websocket：客户端向服务端发送特殊请求建立长久连接，可以完成实时双向通信</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>JDK：@ServerEndpoint</li>
<li>Spring：@MessageMapping、@SubscribeMapping、@SendTo</li>
</ol>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ol>
<li>跨域问题由浏览器的同源策略引起，这是浏览器对javascript强制施加的安全限制</li>
<li>同源策略要求域名、端口、协议相同，否则就是跨域</li>
<li>跨域问题会限制读取Cookie、获取JS对象、发送Ajax请求</li>
</ol>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（跨域资源共享）是处理跨域问题的一种解决方案，通过在请求头中配置<code>Access-Control-Allow-Origin</code>属性进而允许浏览器忽略对指定域名发送跨域请求的限制。</p>
<ol>
<li><code>Access-Control-Allow-Origin</code>：允许指定域名跨域</li>
<li><code>Access-Control-Allow-Methods</code>：允许指定方法跨域</li>
<li><code>Access-Control-Allow-Headers</code>：允许指定请求头字段跨域</li>
<li><code>Access-Control-Max-Age</code>：OPTION预检测间隔时间</li>
</ol>
<p>可以在HTTP请求的发送、转发、响应任意阶段配置CORS</p>
<h3 id="spring跨域"><a href="#spring跨域" class="headerlink" title="spring跨域"></a>spring跨域</h3><ol>
<li><code>CorsFilter</code></li>
<li><code>WebMvcConfigurer</code></li>
<li><code>@CrossOrigin</code></li>
<li><code>response.addHeader</code></li>
<li><code>Filter</code></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/04/15/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/15/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">java内存模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-15 14:42:03 / 修改时间：16:58:13" itemprop="dateCreated datePublished" datetime="2024-04-15T14:42:03+08:00">2024-04-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java内存模型简介"><a href="#Java内存模型简介" class="headerlink" title="Java内存模型简介"></a>Java内存模型简介</h2><p>Java内存模型主要由三个部分构成：1个主内存、n个线程、n个线程工作内存，Java提供了8个原子操作用于在三者之间操作数据：<code>lock</code>、<code>unlock</code>、<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>、<code>write</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">主内存 --&gt; read --&gt; load --&gt; 工作内存 --&gt; use --&gt; Java线程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Java线程 --&gt; assign --&gt; 工作内存 --&gt; store --&gt; write --&gt; 主内存</span><br></pre></td></tr></table></figure>

<h2 id="8个原子操作"><a href="#8个原子操作" class="headerlink" title="8个原子操作"></a>8个原子操作</h2><ol>
<li><code>lock</code>：作用于主内存，把一个变量标识为一个线程独占状态。</li>
<li><code>unlock</code>：作用于主内存，释放一个处于锁定状态的变量。</li>
<li><code>read</code>：作用于主内存，把一个变量的值从主内存传输到线程工作内存中，供之后的<code>load</code>操作使用。</li>
<li><code>load</code>：作用于工作内存，把<code>read</code>操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><code>use</code>：作用于工作内存，把工作内存中的一个变量传递给执行引擎，虚拟机遇到使用变量值的字节码指令时会执行。</li>
<li><code>assign</code>：作用于工作内存，把一个从执行引擎得到的值赋给工作内存的变量，虚拟机遇到给变量赋值的字节码指令时会执行。</li>
<li><code>store</code>：作用于工作内存，把工作内存中的一个变量传送到主内存中，供之后的<code>write</code>操作使用。</li>
<li><code>write</code>：作用于主内存，把<code>store</code>操作从工作内存中得到的变量值存入主内存的变量中。</li>
</ol>
<h3 id="执行规则"><a href="#执行规则" class="headerlink" title="执行规则"></a>执行规则</h3><h4 id="变量拷贝规则"><a href="#变量拷贝规则" class="headerlink" title="变量拷贝规则"></a>变量拷贝规则</h4><ul>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>单独出现</li>
<li>不允许线程丢弃它最近的<code>assign</code>操作，即工作内存变化之后必须把该变化同步回主内存中</li>
<li>不允许一个线程在没有<code>assign</code>的情况下将工作内存同步回主内存中，也就是说，只有虚拟机遇到变量赋值的字节码时才会将工作内存同步回主内存</li>
<li>新的变量只能从主内存中诞生，即不能在工作内存中使用未被<code>load</code>和<code>assign</code>的变量，一个变量在<code>use</code>和<code>store</code>前一定先经过了<code>load</code>和<code>assign</code></li>
</ul>
<h4 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h4><ul>
<li>一个变量在同一时刻只允许一个线程对其进行<code>lock</code>操作，但是可以被一个线程多次<code>lock</code>（锁的可重入）</li>
<li>对一个变量进行<code>lock</code>操作会清空这个变量在工作内存中的值，然后在执行引擎使用这个变量时，需要通过<code>assign</code>或<code>load</code>重新对这个变量进行初始化</li>
<li>对一个变量执行<code>unlock</code>前，必须将该变量同步回主内存中，即执行<code>store</code>和<code>write</code>操作</li>
<li>一个变量没有被<code>lock</code>，就不能被<code>unlock</code>，也不能去<code>unlock</code>一个被其他线程<code>lock</code>的变量</li>
</ul>
<h2 id="可见性问题-有序性问题"><a href="#可见性问题-有序性问题" class="headerlink" title="可见性问题 -&gt; 有序性问题"></a>可见性问题 -&gt; 有序性问题</h2><p>线程只能操作自己的工作内存，其对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。这就有可能会导致可见性问题：</p>
<ol>
<li>因为对于主内存中的变量 A，其在不同的线程的工作内存中可能存在不同的副本 A1、A2、A3。</li>
<li>不同线程的<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>不一定是连续执行的，中间可以插入其他命令。Java只能保证<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>的执行对于一个线程而言是连续的，但是并不保证不同线程的<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>的执行是连续的。</li>
</ol>
<p>可见性问题的本身，也是由于不同线程之间的执行顺序得不到保证导致的，因此可以将它的解决和有序性合并，即对Java一些指令的操作顺序进行限制，这样既保证了有序性，有解决了可见性。</p>
<h3 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h3><p>Happens-Before规则是一种顺序约束规范，用来约束编译器的优化行为，它要求前面的操作的结果对后面的操作一定是可见的。</p>
<p>根据类别，可以将Happens-Before规则分为4类：</p>
<ol>
<li>操作的顺序：<ul>
<li><strong>程序顺序规则：</strong> 如果代码中操作 A 在操作 B 之前，那么同一个线程中 A 操作一定在 B 操作前执行，即在本线程内观察，所有操作都是有序的。</li>
<li><strong>传递性：</strong> 在同一个线程中，如果 A 先于 B ，B 先于 C 那么 A 必然先于 C。</li>
</ul>
</li>
<li>锁和 volatile：<ul>
<li><strong>监视器锁规则：</strong> 监视器锁的解锁操作必须在同一个监视器锁的加锁操作前执行。</li>
<li><strong>volatile 变量规则：</strong> 对 volatile 变量的写操作必须在对该变量的读操作前执行，保证时刻读取到这个变量的最新值。</li>
</ul>
</li>
<li>线程和中断：<ul>
<li><strong>线程启动规则：</strong> <code>Thread#start()</code> 方法一定先于该线程中执行的操作。</li>
<li><strong>线程结束规则：</strong> 线程的所有操作先于线程的终结。</li>
<li><strong>中断规则：</strong> 假设有线程 A，其他线程 interrupt A 的操作先于检测 A 线程是否中断的操作，即对一个线程的 <code>interrupt()</code> 操作和 <code>interrupted()</code>等检测中断的操作同时发生，那么 <code>interrupt()</code> 先执行。</li>
</ul>
</li>
<li>对象生命周期相关：<ul>
<li><strong>终结器规则：</strong> 对象的构造函数执行先于 <code>finalize()</code> 方法。</li>
</ul>
</li>
</ol>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>volatile 变量有以下两个特点：</p>
<ol>
<li>保证对所有线程的可见性。</li>
<li>禁止指令重排序优化。</li>
</ol>
<p>Happens-Before规则中要求，对volatile变量的写操作必须在对该变量的读操作前执行，解决方法分两步：</p>
<ol>
<li>保证动作发生；</li>
<li>保证动作按正确的顺序发生。</li>
</ol>
<p>首先，在对volatile变量进行读取和写入操作时，必须去主内存拉取最新值，或是将最新值更新进主内存，不能只更新进工作内存而不将操作同步进主内存，即在执行 <code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>、<code>write</code> 操作时：</p>
<ol>
<li>对于一个线程，<code>use</code> 操作必须与 <code>load</code>、<code>read</code> 操作同时出现；</li>
<li>对于一个线程，<code>assign</code> 操作必须与 <code>store</code>、<code>write</code> 操作同时出现；</li>
<li>对于多个线程，一个线程执行<code>use</code>操作后，其他线程必须等它继续执行完<code>load</code>和<code>read</code>操作；</li>
<li>对于多个线程，一个线程执行<code>assign</code>操作后，其他线程必须等它继续执行完<code>store</code>和<code>write</code>操作；</li>
</ol>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>在Java中利用了 <code>lock</code> 操作的特点实现了volatile原理：编译volatile变量的赋值操作时，在后面额外加了一行：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给<span class="built_in">ESP</span>寄存器+<span class="number">0</span></span><br><span class="line"><span class="keyword">lock</span> addl <span class="number">$0</span>x0,(%esp)</span><br></pre></td></tr></table></figure>

<ol>
<li>保证动作发生：<ul>
<li><code>lock</code> 指令会将当前 CPU 的 Cache 写入内存，并无效化其他 CPU 的 Cache，相当于在执行了 <code>assign</code> 后，又进行了 <code>store</code> -&gt; <code>write</code>；</li>
<li>这使得其他 CPU 可以立即看见 volatile 变量的修改，因为其他 CPU 在读取 volatile 变量时，会发现自己的缓存过期了，于是会去主内存中拉取最新的 volatile 变量值，也就被迫在 <code>use</code>前进行一次 <code>read</code> -&gt; <code>load</code>。</li>
</ul>
</li>
<li>保证动作顺序：<ul>
<li><code>lock</code> 的存在相当于一个内存屏障，使得在重排序时，不能把后面的指令排在内存屏障之前。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/04/10/Java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/10/Java%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-10 08:52:15" itemprop="dateCreated datePublished" datetime="2024-04-10T08:52:15+08:00">2024-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-07 00:12:08" itemprop="dateModified" datetime="2024-05-07T00:12:08+08:00">2024-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java并发是指多个线程同时执行一段代码，共享同一个资源，同时为了协调多个线程，需要用到锁等机制来保证数据的完整性和一致性。在Java中，通过多线程实现并发操作可以提高程序的执行效率，充分利用系统资源。</p>
<ol>
<li>并发：多个任务在同一个时间段内轮流执行（时间重叠，不是同时执行）。</li>
<li>并行：多个任务在同一个时间段内同时执行（时间重叠，同时执行）。</li>
<li>同步：一个任务发出一个调用，必须一直等待该调用返回结果才能继续。</li>
<li>异步：一个任务发出一个调用，不需要等待该调用返回结果就可以继续。</li>
<li>进程：程序运行的实例，拥有独立的内存空间，系统运行程序是进程从创建、运行到结束的一个过程。通过main方法启动的Java程序就是一个JVM的进程，main方法只是进程中的一个线程。</li>
<li><strong>线程</strong>：线程是进程执行的最小单位，它允许进程同时执行多个任务。</li>
<li><strong>线程安全</strong>：多个线程同时访问同一个资源，能保证该资源的数据正确性和一致性。</li>
<li>线程同步：通过同步机制控制多个线程对共享资源的访问，保证该资源的数据正确性和一致性。</li>
<li><strong>锁</strong>：锁是一种同步机制，用来保护对共享资源的访问。</li>
<li>阻塞：阻塞是指线程因为某些条件不满足而暂停执行，并且一直等待条件满足；非阻塞编程模式运行线程在等待时继续执行其他任务。</li>
<li>死锁：多个线程相互等待对方释放共享资源，且等待时不释放自己已经获取的资源，从而导致各自都无法继续执行。</li>
<li>并发集合：Java提供的线程安全的集合类，用于多线程环境下操作和管理数据。</li>
<li>线程池：线程池是一种创建和管理线程的方式，它可以重用一组固定数量的线程来执行多个任务。</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>线程的生命周期描述了一个线程从创建到销毁的整个过程，一般包括以下几个状态：</p>
<ol>
<li><p>新建状态（New）：当一个 Thread 对象被创建时，它处于新建状态。此时线程对象已经被创建，但尚未启动。可以通过调用 start() 方法来启动线程。</p>
</li>
<li><p>就绪状态（Runnable）：当线程被启动后，它进入就绪状态。处于就绪状态的线程已经被系统加载到内存中，可以随时被执行，但并没有分配到 CPU 时间片。处于就绪状态的线程等待系统调度器的调度。</p>
</li>
<li><p>运行状态（Running）：当线程获得 CPU 时间片并开始执行时，它进入运行状态。处于运行状态的线程正在执行其任务代码。</p>
</li>
<li><p>阻塞状态（Blocked）：当线程因为某些原因被阻塞时，它进入阻塞状态。线程可能被阻塞于 I&#x2F;O 操作、获取锁、等待其他线程的通知等情况。处于阻塞状态的线程不会消耗 CPU 时间，直到阻塞条件被解除。</p>
</li>
<li><p>等待状态（Waiting）：当线程调用 wait()、join()、park() 等方法时，它进入等待状态。处于等待状态的线程需要等待其他线程的通知或者特定条件的满足才能继续执行。</p>
</li>
<li><p>超时等待状态（Timed-Waiting）：与等待状态类似，但是在等待一段指定的时间后会自动恢复到就绪状态或者阻塞状态。线程可能因为调用 sleep()、join(timeout)、wait(timeout) 等方法进入超时等待状态。</p>
</li>
<li><p>终止状态（Terminated）：当线程执行完其任务代码或者由于异常等原因提前结束时，它进入终止状态。处于终止状态的线程已经完成了它的生命周期，无法再次被启动。</p>
</li>
</ol>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ol>
<li><code>start()</code>：启动线程，使线程进入就绪状态，等待系统调度执行。</li>
<li><code>run()</code>：线程的执行体，包含了线程要执行的任务代码。需要自行实现该方法，通常通过继承 Thread 类或实现 Runnable 接口来重写该方法。</li>
<li><code>sleep(long millis)</code>：让当前线程睡眠指定的时间，单位为毫秒。线程在睡眠期间不会释放锁，用于模拟线程的等待或延迟执行。</li>
<li><code>yield()</code>：提示线程调度器当前线程愿意放弃当前 CPU 时间片，让出 CPU 资源，使其他具有相同优先级的线程有机会执行。但并不保证一定会让出 CPU 时间片，取决于线程调度器的具体实现。</li>
<li><code>join()</code>：等待该线程执行完成。调用该方法的线程将会被阻塞，直到目标线程执行完成或者指定的超时时间到达。</li>
<li><code>interrupt()</code>：中断线程，给目标线程发送一个中断信号，使其中断阻塞状态或者等待状态。通常通过检查中断标志来处理中断。</li>
<li><code>isInterrupted()</code>：检查线程的中断状态，返回一个布尔值，表示线程是否被中断。</li>
<li><code>interrupted()</code>：静态方法，检查当前线程的中断状态，并清除中断标志。通常用于线程自身的中断状态查询。</li>
<li><code>getState()</code>：获取线程的状态，返回一个 Thread.State 枚举值，表示线程当前的状态。</li>
<li><code>setName(String name)</code> 和 <code>getName()</code>：设置和获取线程的名称，用于标识和区分不同的线程。</li>
<li><code>isAlive()</code>：检查线程是否还活跃，即线程是否处于就绪、运行或阻塞状态。</li>
<li><code>wait()</code> ：用于使当前线程进入等待状态，并释放对象的锁。调用 <code>wait()</code> 方法的线程会一直等待，直到其他线程调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法来唤醒它，或者等待时间到达。<ul>
<li><code>wait()</code>：线程无限期等待，直到被唤醒或者中断。</li>
<li><code>wait(long timeout)</code>：线程等待指定的时间，直到被唤醒、中断或者等待时间到达。</li>
<li><code>wait(long timeout, int nanos)</code>：线程等待指定的时间加上纳秒数，直到被唤醒、中断或者等待时间到达。</li>
</ul>
</li>
<li><code>notify()</code>：用于唤醒一个正在等待的线程。调用 <code>notify()</code>方法会通知等待该对象锁的线程中的一个线程可以继续执行。被唤醒的线程会重新竞争对象的锁。如果有多个线程等待同一个对象的锁，调用 <code>notify()</code><br>方法只会唤醒其中一个线程，具体唤醒哪一个线程是不确定的，取决于线程调度器的实现。</li>
<li><code>notifyAll()</code>：用于唤醒所有正在等待的线程。调用 <code>notifyAll()</code> 方法会通知所有等待该对象锁的线程，告诉它们可以继续执行了。被唤醒的线程会重新竞争对象的锁。</li>
</ol>
<p>注意事项：</p>
<ul>
<li><code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法必须在同步代码块或者同步方法中调用，即必须先获得对象的锁才能调用这些方法。</li>
<li>在调用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法时，线程必须拥有对象的监视器锁（也就是对象的锁）。</li>
<li>通常与 <code>wait()</code> 方法一起使用的是一个循环，用于检查条件是否满足，防止虚假唤醒。</li>
</ul>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ol>
<li>继承Thread类重写run()方法</li>
<li>实现Runnable接口重写run()方法，最后用Thread类包装</li>
<li>实现Callable接口重写call()方法，使用FutureTask类包装，最后用Thread类包装FutureTask</li>
<li>通过Executors线程池工具类创建线程</li>
</ol>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ol>
<li>synchronized和volatile关键字：volatile变量可以保证可见性；</li>
<li>同步&#x2F;等待机制：通过wait()、notify()实现线程阻塞和唤醒；</li>
<li>Thread类join()：控制线程执行顺序</li>
<li>管道流：<code>new PipedInputStream().connect(new PipedOutputStream())</code></li>
</ol>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>要保证并发访问的安全性，可以从以下角度出发：</p>
<ol>
<li>访问状态变量时使用同步，即避免多个线程在同一时刻访问相同数据：线程同步</li>
<li>确保被访问的对象是线程安全的：可见性、共享变量只读&#x2F;不可变、线程安全容器</li>
<li>不在线程之间共享任何变量：变量线程独享</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>java中，锁是一种同步机制，用于线程同步和并发控制，从而保护对共享资源的访问。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>锁名称</th>
<th>应用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>乐观锁</td>
<td>CAS</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>悲观锁</td>
<td>synchronized、ReentrantLock、vector、hashtable</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>自旋锁</td>
<td>CAS</td>
<td>适用于锁被占用时间短、线程数量少的情况</td>
</tr>
<tr>
<td>4</td>
<td>自适应自旋锁</td>
<td>CAS</td>
<td>减少自旋次数过多带来的性能损失</td>
</tr>
<tr>
<td>5</td>
<td>可重入锁</td>
<td>synchronized、ReentrantLock、Lock</td>
<td>递归函数内部再次调用自身</td>
</tr>
<tr>
<td>6</td>
<td>递归锁</td>
<td>synchronized、ReentrantLock、Lock</td>
<td>可重入锁</td>
</tr>
<tr>
<td>7</td>
<td>读写锁</td>
<td>ReentrantReadWriteLock、CopyOnWriteArrayList、CopyOnWriteArraySet</td>
<td>读操作频繁、写操作较少的场景</td>
</tr>
<tr>
<td>8</td>
<td>公平锁</td>
<td>ReentrantLock(true)</td>
<td>保证线程获取锁的公平性</td>
</tr>
<tr>
<td>9</td>
<td>非公平锁</td>
<td>synchronized、ReentrantLock(false)</td>
<td>允许线程插队，可能导致线程饥饿</td>
</tr>
<tr>
<td>10</td>
<td>共享锁</td>
<td>ReentrantReadWriteLock的读锁</td>
<td>读多写少的场景</td>
</tr>
<tr>
<td>11</td>
<td>独占锁</td>
<td>synchronized、vector、hashtable、ReentrantReadWriteLock的写锁</td>
<td>写操作频繁的场景</td>
</tr>
<tr>
<td>12</td>
<td>互斥锁</td>
<td></td>
<td>保护临界区，避免竞态条件和数据不一致等并发问题</td>
</tr>
<tr>
<td>13</td>
<td>重量级锁</td>
<td>synchronized</td>
<td>通过操作系统的互斥量实现的锁，效率较低</td>
</tr>
<tr>
<td>14</td>
<td>轻量级锁</td>
<td></td>
<td>通过CAS操作等底层机制实现的锁，效率较高</td>
</tr>
<tr>
<td>15</td>
<td>偏向锁</td>
<td></td>
<td>单线程访问场景的优化手段</td>
</tr>
<tr>
<td>16</td>
<td>分段锁</td>
<td>ConcurrentHashMap</td>
<td>并发哈希表等数据结构的实现</td>
</tr>
<tr>
<td>17</td>
<td>同步锁</td>
<td>synchronized</td>
<td>保护临界区、避免竞态条件等并发问题</td>
</tr>
<tr>
<td>18</td>
<td>锁粗化</td>
<td></td>
<td>将多个连续的同步块合并为一个更大的同步块，减少锁的获取和释放次数</td>
</tr>
<tr>
<td>19</td>
<td>锁消除</td>
<td></td>
<td>在 JIT 编译时去除不必要的同步操作，减少锁的使用</td>
</tr>
</tbody></table>
<h3 id="常见锁"><a href="#常见锁" class="headerlink" title="常见锁"></a>常见锁</h3><h4 id="内置锁（Intrinsic-Lock）"><a href="#内置锁（Intrinsic-Lock）" class="headerlink" title="内置锁（Intrinsic Lock）"></a>内置锁（Intrinsic Lock）</h4><ul>
<li><strong>概念</strong>：<ul>
<li>内置锁是 Java 中最基本的锁机制，也称为对象监视器锁或 <code>synchronized</code> 锁。</li>
<li>通过 <code>synchronized</code> 关键字或者 <code>Object</code> 类的 <code>wait()</code> 和 <code>notify()</code> 方法实现，用于对代码块或方法进行同步控制。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>每个对象都有一个关联的监视器锁，当一个线程进入同步代码块或方法时，它会尝试获取对象的监视器锁。</li>
<li>如果对象的监视器锁没有被其他线程持有，则当前线程获取到锁，可以执行同步代码；否则线程会被阻塞，直到获取到锁为止。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>内置锁的底层实现依赖于 Java 虚拟机的内置机制，通常是基于操作系统的原子操作指令实现锁的获取和释放。</li>
</ul>
</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li><strong>概念</strong>：<ul>
<li>ReentrantLock 是可重入锁的一种实现，位于 <code>java.util.concurrent.locks</code> 包中。</li>
<li>它提供了与 <code>synchronized</code> 类似的功能，但更加灵活，可以实现公平性、可中断性等特性。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>ReentrantLock 是基于 <code>AbstractQueuedSynchronizer (AQS)</code> 实现的，使用了 CAS 操作来保证多个线程对锁的并发访问。</li>
<li>每个 ReentrantLock 实例都持有一个 AQS 的实例，通过 acquire 和 release 方法来获取和释放锁。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>ReentrantLock 的底层实现使用了类似于 CAS 操作的 compareAndSetState 方法来管理锁的状态和等待队列。</li>
</ul>
</li>
</ul>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><ul>
<li><strong>概念</strong>：<ul>
<li>ReadWriteLock 是读写锁，位于 <code>java.util.concurrent.locks</code> 包中。</li>
<li>允许多个线程同时读取共享资源，但只允许一个线程写入共享资源，以提高读操作的并发性能。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>ReadWriteLock 包含两个锁，一个读锁和一个写锁。当没有线程持有写锁时，多个线程可以同时持有读锁；当有线程持有写锁时，其他线程无法获取读锁或写锁。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>ReadWriteLock 的底层实现通常是 ReentrantReadWriteLock，它使用了类似于 ReentrantLock 的方式来管理读锁和写锁的状态。</li>
</ul>
</li>
</ul>
<h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><ul>
<li><strong>概念</strong>：<ul>
<li>StampedLock 是 Java 8 新增的锁机制，位于 <code>java.util.concurrent.locks</code> 包中。</li>
<li>提供了乐观读、悲观读和写入的功能，可以根据不同的情况选择最适合的锁定方式。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>StampedLock 提供了乐观读锁和悲观读锁，乐观读锁的获取不会阻塞其他线程的写入操作，但在使用乐观读锁时需要使用 validate 方法来验证数据是否被修改。</li>
<li>悲观读锁和写锁是独占锁，写锁会阻塞其他读锁和写锁的获取。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>StampedLock 的底层实现与 ReentrantLock 类似，也是基于 <code>AbstractQueuedSynchronizer (AQS)</code> 实现的，但它使用了 stamped 概念来标记锁的状态，通过 stamped<br>的值来判断锁的状态以及是否需要重新尝试获取锁。</li>
</ul>
</li>
</ul>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><ul>
<li><strong>概念</strong>：<ul>
<li>ReentrantReadWriteLock 是 ReadWriteLock 接口的一种实现，支持可重入的读写锁，允许同一个线程多次获取读锁或写锁。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>ReentrantReadWriteLock 内部维护了读锁和写锁的数量，允许同一个线程在持有读锁或写锁的情况下再次获取相同类型的锁。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>ReentrantReadWriteLock 的底层实现与 ReentrantLock 类似，也是基于 <code>AbstractQueuedSynchronizer (AQS)</code>实现的，但它使用了两个计数器来分别记录读锁和写锁的数量。</li>
</ul>
</li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><ul>
<li><strong>概念</strong>：<ul>
<li>Semaphore（信号量）用于控制同时访问某个资源的线程数量。</li>
<li>它可以控制在同一时刻有多少个线程可以访问共享资源，常用于限流和资源池管理等场景。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>Semaphore 内部维护了一个计数器和一个等待队列。</li>
<li>当线程尝试获取信号量时，如果计数器大于 0，则线程获取到信号量，计数器减一；如果计数器等于 0，则线程会被阻塞，直到有其他线程释放信号量。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>Semaphore 的底层实现通常使用了类似于 ReentrantLock 的方式来保护计数器和等待队列，以及实现线程的阻塞和唤醒。</li>
</ul>
</li>
</ul>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><ul>
<li><strong>概念</strong>：<ul>
<li>CountDownLatch（倒计时门闩）用于线程间的同步等待。</li>
<li>一个或多个线程等待其他线程执行完毕后再执行，可以通过 <code>countDown()</code> 和 <code>await()</code> 方法实现。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>CountDownLatch 内部维护了一个计数器，当计数器值为 0 时，所有等待的线程都会被唤醒。</li>
<li>线程执行 <code>countDown()</code> 方法时，计数器减一；线程执行 <code>await()</code> 方法时，如果计数器值不为 0，则线程会被阻塞，直到计数器值为 0。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>CountDownLatch 的底层实现通常使用了类似于 ReentrantLock 和 Condition 的方式来保护计数器和等待队列，以及实现线程的阻塞和唤醒。</li>
</ul>
</li>
</ul>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><ul>
<li><strong>概念</strong>：<ul>
<li>CyclicBarrier（循环栅栏）用于线程间的同步等待，允许一组线程互相等待，直到到达某个公共屏障点后再继续执行。</li>
<li>它可以用于多个线程之间相互等待，直到所有线程都到达某个点后再继续执行，常用于分布式计算和并行计算场景。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>CyclicBarrier 内部维护了一个计数器和一个屏障动作。</li>
<li>当线程调用 <code>await()</code> 方法时，计数器减一，然后线程被阻塞，直到计数器值为 0。</li>
<li>当计数器值为 0 时，所有等待的线程都会被释放，并且执行屏障动作。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>CyclicBarrier 的底层实现通常使用了类似于 ReentrantLock 和 Condition 的方式来保护计数器和等待队列，以及实现线程的阻塞和唤醒。</li>
</ul>
</li>
</ul>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><ul>
<li><strong>概念</strong>：<ul>
<li>LockSupport 是用于线程的阻塞和唤醒操作的工具类。</li>
<li>它可以让线程在任意位置阻塞，并且可以在任意位置唤醒被阻塞的线程。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>LockSupport 主要提供了 <code>park()</code> 和 <code>unpark()</code> 两个静态方法来实现线程的阻塞和唤醒。</li>
<li><code>park()</code> 方法用于阻塞当前线程，而 <code>unpark()</code> 方法用于唤醒指定线程。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>LockSupport 的底层实现通常依赖于操作系统的原子操作指令，比如 Linux 下的 futex（Fast Userspace Mutex）。</li>
</ul>
</li>
</ul>
<h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h4><ul>
<li><strong>概念</strong>：<ul>
<li>Phaser（阶段器）用于协调多个线程的执行阶段。</li>
<li>它允许一组线程互相等待，直到到达某个阶段后再继续执行，可以动态地注册和注销参与者。</li>
</ul>
</li>
<li><strong>原理</strong>：<ul>
<li>Phaser 内部维护了一个阶段数和一个参与者计数器。</li>
<li>当所有参与者都到达某个阶段时，Phaser 会进入下一个阶段，并且唤醒所有等待的线程。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>Phaser 的底层实现通常使用了类似于 ReentrantLock 和 Condition 的方式来保护阶段数和参与者计数器，以及实现线程的阻塞和唤醒。</li>
</ul>
</li>
</ul>
<h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>synchronized是Java中用于实现同步的关键字，它可以应用于方法或代码块中。使用synchronized关键字可以确保多个线程在访问共享资源时的安全性，避免出现竞态条件（Race Condition）等问题。</p>
<p><strong>synchronized是互斥锁，在同一时刻只会有一个线程拿到锁对象</strong></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock对象) &#123;</span><br><span class="line">    // 同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰普通方法"><a href="#修饰普通方法" class="headerlink" title="修饰普通方法"></a>修饰普通方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void getValue() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">// 相当于:</span><br><span class="line">class X &#123;</span><br><span class="line">    synchronized(this) public void getValue() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized public static void getValue() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">// 相当于:</span><br><span class="line">class X &#123;</span><br><span class="line">    synchronized(X.class) public void getValue() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized是可重入锁，拿到锁的线程可以再次拿到锁</strong></p>
<h4 id="可重入锁实现"><a href="#可重入锁实现" class="headerlink" title="可重入锁实现"></a>可重入锁实现</h4><ul>
<li>为每个锁关联一个获取该锁的次数的计数器 count，和一个所有者线程；</li>
<li>count &#x3D; 0 时，说明没有线程持有该锁；</li>
<li>当一个线程获取一个未被持有的锁时，JVM 记下锁的持有者，并 count &#x3D; 1；</li>
<li>当这个线程再次获取锁时，count++；</li>
<li>当线程退出同步代码块时，count–；</li>
<li>当 count 再次减为 0 时，锁被释放。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>synchronized</code>是java中的一种内置锁，也称为对象监视器锁（Monitor Lock）或互斥锁（Mutex<br>Lock）。在java中，每个对象都有一个与之关联的监视器，用于控制对对象的并发访问。当一个线程进入了一个<code>synchronized</code><br>方法或代码块时，它会尝试获取对象的监视器锁，如果获取成功，则可以执行同步代码；如果获取失败，则线程会被阻塞，直到获取到锁为止。</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>Java 的对象头主要包含几部分：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32&#x2F;64 bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode和锁信息</td>
</tr>
<tr>
<td>32&#x2F;64 bit</td>
<td>Class Metadata Address</td>
<td>存储对象类型数据的指针</td>
</tr>
<tr>
<td>32 bit</td>
<td>Array length</td>
<td>数组的长度（数组对象才有）</td>
</tr>
</tbody></table>
<h5 id="Monitor-Record"><a href="#Monitor-Record" class="headerlink" title="Monitor Record"></a>Monitor Record</h5><p>Monitor Record是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor record关联（对象头的 MarkWord中的<br>LockWord 指向 monitor record 的起始地址），同时 monitor record 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>如下为 Monitor Record 的内部结构：</p>
<table>
<thead>
<tr>
<th>monitor record 元素</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Owner</strong></td>
<td>初始时为 null,表示当前没有任何线程拥有该 monitor，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为 null</td>
</tr>
<tr>
<td>EntryQ</td>
<td>阻塞所有试图锁住 monitor record 失败的线程</td>
</tr>
<tr>
<td>RcThis</td>
<td>表示 blocked 或 waiting 在该 monitor record 上的所有线程的个数</td>
</tr>
<tr>
<td><strong>Nest</strong></td>
<td>实现重入锁的计数</td>
</tr>
<tr>
<td>HashCode</td>
<td>保存从对象头拷贝过来的 HashCode 值</td>
</tr>
<tr>
<td>Candidate</td>
<td>0 表示没有需要唤醒的线程，1 表示要唤醒一个继任线程来竞争锁</td>
</tr>
</tbody></table>
<h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><ol>
<li>synchronized 关键字的底层原理是基于对象头中的 Mark Word 和线程的监视器（Monitor）实现的。每个对象都有一个与之关联的监视器，用于控制对对象的并发访问。</li>
<li>当线程进入一个 synchronized 方法或代码块时，会尝试获取对象的监视器锁。如果对象的监视器锁没有被其他线程持有，则当前线程获取到锁，可以执行同步代码；如果锁被其他线程持有，则当前线程将被阻塞，直到获取到锁为止。</li>
<li>当线程执行完同步代码后，会释放对象的监视器锁，唤醒其他等待获取该锁的线程。</li>
<li>在方法上使用 synchronized 关键字时，锁对象是当前实例对象（即 this），在静态方法上使用 synchronized 关键字时，锁对象是当前类的 Class 对象。</li>
</ol>
<h5 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h5><p><code>synchronized</code> 锁在 Java 中是最常用的一种同步机制，但它在一些场景下可能存在性能问题。为了提高性能，Java 虚拟机和编译器在多个版本中对 <code>synchronized</code> 锁进行了优化，主要包括以下几个方面：</p>
<ol>
<li><p><strong>自适应自旋（Adaptive Spinning）</strong>：</p>
<ul>
<li>在 JDK 6 中引入了自适应自旋技术，通过统计当前锁的竞争情况来动态调整自旋次数。</li>
<li>当一个线程尝试获取一个被其他线程持有的锁时，如果锁的持有时间很短，Java 虚拟机可能会让线程进行自旋等待，避免线程进入阻塞状态，从而降低线程切换的开销。</li>
</ul>
</li>
<li><p><strong>偏向锁（Biased Locking）</strong>：</p>
<ul>
<li>JDK 6 引入了偏向锁技术，用于在无竞争的情况下提高锁的性能。</li>
<li>当一个线程获取锁时，如果该锁没有被其他线程持有，Java 虚拟机会将锁的标记设置为偏向该线程，后续获取锁的操作会快速执行，不需要进行同步操作。</li>
<li>如果其他线程尝试获取同一个锁时，偏向锁会自动升级为轻量级锁或者重量级锁。</li>
</ul>
</li>
<li><p><strong>轻量级锁（Lightweight Locking）</strong>：</p>
<ul>
<li>在 JDK 6 中，当一个线程尝试获取一个被其他线程持有的锁时，Java 虚拟机会将锁的标记设置为轻量级锁。</li>
<li>轻量级锁通过 CAS 操作来尝试获取锁，避免了线程阻塞和唤醒的开销，提高了锁的竞争效率。</li>
<li>如果 CAS 操作失败，表示锁竞争激烈，锁会升级为重量级锁。</li>
</ul>
</li>
<li><p><strong>锁消除（Lock Elimination）</strong>：</p>
<ul>
<li>Java 虚拟机会通过逃逸分析来检测代码中是否存在不需要同步的场景，如果不存在共享数据，就可以将 <code>synchronized</code> 锁消除掉，减少同步开销。</li>
<li>例如，如果一个对象只在单个线程中使用，或者在线程栈上分配的对象，Java 虚拟机会认为这些对象不会被其他线程访问，可以消除相应的锁。</li>
</ul>
</li>
</ol>
<p>通过这些优化技术，<code>synchronized</code> 锁的性能得到了大幅提升，同时保持了线程安全性。在实际开发中，建议使用 <code>synchronized</code> 锁来保证程序的正确性和线程的安全性，避免出现并发问题。</p>
<h2 id="AQS-和-CAS"><a href="#AQS-和-CAS" class="headerlink" title="AQS 和 CAS"></a>AQS 和 CAS</h2><h3 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）"></a>AQS（AbstractQueuedSynchronizer）</h3><p>AQS是Java中用来构建锁和其他同步组件的抽象基类，它提供了一种基于队列的锁和同步器框架，可以轻松实现各种同步器，如互斥锁、读写锁、信号量等。AQS使用了一种先进先出（FIFO）的等待队列来管理等待线程，并且提供了基于CAS操作的原子更新机制来保证多线程的安全访问。</p>
<h3 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h3><p>CAS是一种基于原子操作的并发控制机制，常用于实现非阻塞算法和乐观锁。它通过比较内存中的值和期望值是否相等，如果相等，则将内存中的值更新为新值，否则不做任何操作。<br>CAS操作通常包括三个参数：要操作的内存位置（地址）、期望值和新值。如果内存位置的值等于期望值，则用新值更新内存位置的值，否则操作失败。CAS 操作是一种无锁的并发控制机制，因此在高并发场景下具有较好的性能表现。<br>CAS操作由<code>sun.misc.Unsafe</code>提供支持，但并不推荐直接使用<code>Unsafe</code>类，而是通过<code>java.util.concurrent.atomic</code>包中的原子类来间接使用CAS操作，如<code>AtomicInteger</code>。<br>这些原子类封装了CAS操作，提供了更方便、安全的方式来进行原子操作。CAS操作通常结合循环重试来实现非阻塞算法，以处理并发冲突。</p>
<h3 id="Java中的原子类"><a href="#Java中的原子类" class="headerlink" title="Java中的原子类"></a>Java中的原子类</h3><p>Java中的原子类是一组提供了原子操作的类，位于<code>java.util.concurrent.atomic</code><br>包中。这些原子类能够在多线程环境下安全地执行读取、写入和更新操作，而不需要额外的同步控制（如synchronized关键字）。原子类主要通过CAS（Compare-And-Swap）操作来实现线程安全的并发控制。</p>
<ol>
<li><strong>AtomicBoolean</strong>：提供对boolean类型的原子操作。</li>
<li><strong>AtomicInteger</strong>：提供对int类型的原子操作。</li>
<li><strong>AtomicLong</strong>：提供对long类型的原子操作。</li>
<li><strong>AtomicReference</strong>：提供对引用类型的原子操作。</li>
<li><strong>AtomicIntegerArray</strong>：提供对int数组类型的原子操作。</li>
<li><strong>AtomicLongArray</strong>：提供对long数组类型的原子操作。</li>
<li><strong>AtomicReferenceArray</strong>：提供对引用类型数组的原子操作。</li>
<li><strong>AtomicIntegerFieldUpdater</strong>：用于更新指定类的int类型字段的原子操作。</li>
<li><strong>AtomicLongFieldUpdater</strong>：用于更新指定类的long类型字段的原子操作。</li>
<li><strong>AtomicReferenceFieldUpdater</strong>：用于更新指定类的引用类型字段的原子操作。</li>
<li><strong>AtomicMarkableReference</strong>：提供对带有标记位的引用类型的原子操作，可以同时更新引用和标记位，主要用于标记某个对象的状态。</li>
<li><strong>AtomicStampedReference</strong>：提供对带有版本号的引用类型的原子操作，可以同时更新引用和版本号，主要用于解决ABA问题。</li>
<li><strong>DoubleAccumulator</strong>：提供对double类型的原子累加操作，支持对多个线程的并发累加操作。</li>
<li><strong>DoubleAdder</strong>：提供对double类型的原子加法操作，支持对多个线程的并发加法操作。</li>
<li><strong>LongAccumulator</strong>：提供对long类型的原子累加操作，支持对多个线程的并发累加操作。</li>
<li><strong>LongAdder</strong>：提供对long类型的原子加法操作，支持对多个线程的并发加法操作。</li>
</ol>
<h2 id="活跃性危险-线程安全问题"><a href="#活跃性危险-线程安全问题" class="headerlink" title="活跃性危险&#x2F;线程安全问题"></a>活跃性危险&#x2F;线程安全问题</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><h3 id="线程饥饿"><a href="#线程饥饿" class="headerlink" title="线程饥饿"></a>线程饥饿</h3><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>Java中的并发容器是为了在多线程环境下提供线程安全的数据结构而设计的。</p>
<ol>
<li><p><strong>ConcurrentHashMap</strong>：线程安全的哈希表实现，用于存储键值对。它支持高并发的读写操作，并提供了比Hashtable更好的性能。</p>
</li>
<li><p><strong>ConcurrentSkipListMap</strong>：基于跳表（SkipList）的并发有序映射表实现，支持并发地插入、删除和访问操作，并提供了比TreeMap更好的并发性能。</p>
</li>
<li><p><strong>ConcurrentSkipListSet</strong>：基于跳表（SkipList）的并发有序集合实现，支持并发地插入、删除和访问操作，并提供了比TreeSet更好的并发性能。</p>
</li>
<li><p><strong>ConcurrentLinkedQueue</strong>：线程安全的非阻塞队列实现，基于链表结构，支持高并发的生产者-消费者模式。</p>
</li>
<li><p><strong>ConcurrentLinkedDeque</strong>：线程安全的非阻塞双端队列实现，基于链表结构，支持高并发的双端操作。</p>
</li>
<li><p><strong>CopyOnWriteArrayList</strong>：线程安全的动态数组实现，通过在写操作时复制整个数组来实现线程安全，适用于读多写少的场景。</p>
</li>
<li><p><strong>CopyOnWriteArraySet</strong>：线程安全的集合实现，基于CopyOnWriteArrayList实现，适用于读多写少的场景。</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong>：线程安全的阻塞队列实现，基于链表结构，支持生产者-消费者模式，并提供了阻塞的插入和移除操作。</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong>：线程安全的阻塞队列实现，基于数组结构，支持生产者-消费者模式，并提供了固定容量的阻塞队列。</p>
</li>
<li><p><strong>PriorityBlockingQueue</strong>：线程安全的优先级队列实现，基于堆结构，支持按优先级顺序插入和移除元素。</p>
</li>
<li><p><strong>ConcurrentHashMap.KeySetView</strong>：ConcurrentHashMap的KeySet视图，是一个并发安全的Set，可以直接对其进行操作而无需考虑并发访问的问题。</p>
</li>
<li><p><strong>ConcurrentHashMap.ValuesView</strong>：ConcurrentHashMap的Values视图，是一个并发安全的Collection，可以直接对其进行操作而无需考虑并发访问的问题。</p>
</li>
<li><p><strong>ConcurrentHashMap.EntrySetView</strong><br>：ConcurrentHashMap的EntrySet视图，是一个并发安全的Set，其中的元素是Map.Entry对象，可以直接对其进行操作而无需考虑并发访问的问题。</p>
</li>
<li><p><strong>ConcurrentLinkedHashMap</strong>：Guava库提供的并发安全的哈希表实现，是ConcurrentHashMap的替代品，支持高并发的读写操作，同时提供了LRU缓存淘汰策略。</p>
</li>
<li><p><strong>LinkedBlockingDeque</strong>：线程安全的阻塞双端队列实现，基于链表结构，支持生产者-消费者模式，并提供了阻塞的双端操作。</p>
</li>
<li><p><strong>ConcurrentLinkedTransferQueue</strong>：JDK 7引入的一种特殊的队列实现，结合了无界队列和阻塞队列的特性，提供了高并发的插入和移除操作。</p>
</li>
<li><p><strong>ConcurrentLinkedBlockingQueue</strong>：线程安全的基于链表结构的阻塞队列实现，是ConcurrentLinkedQueue和LinkedBlockingQueue的结合体，提供了高并发的插入和移除操作。</p>
</li>
<li><p><strong>ConcurrentSkipListMap</strong>：基于跳表（SkipList）的并发有序映射表实现，支持并发地插入、删除和访问操作，并提供了比TreeMap更好的并发性能。</p>
</li>
<li><p><strong>ConcurrentSkipListSet</strong>：基于跳表（SkipList）的并发有序集合实现，支持并发地插入、删除和访问操作，并提供了比TreeSet更好的并发性能。</p>
</li>
</ol>
<h3 id="HashMap-HashTable-TreeMap-ConcurrentHashMap"><a href="#HashMap-HashTable-TreeMap-ConcurrentHashMap" class="headerlink" title="HashMap_HashTable_TreeMap_ConcurrentHashMap"></a>HashMap_HashTable_TreeMap_ConcurrentHashMap</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p><strong>HashMap</strong>：</p>
<ul>
<li>实现方式：基于哈希表的数据结构，使用数组存储键值对，通过哈希算法计算键的索引位置。</li>
<li>线程安全性：非线程安全，不支持并发访问。在多线程环境下使用时，需要通过外部同步机制来保证线程安全。</li>
<li>性能：在无竞争的情况下，性能很好。查找、插入和删除操作的平均时间复杂度为O(1)。</li>
</ul>
</li>
<li><p><strong>HashTable</strong>：</p>
<ul>
<li>实现方式：类似于HashMap，也是基于哈希表的数据结构，但是所有的方法都是同步的。</li>
<li>线程安全性：线程安全，所有的方法都是同步的，支持并发访问。但是由于所有方法都加了synchronized关键字，导致并发性能较差。</li>
<li>性能：相对较低，因为所有方法都加了同步锁，会导致多线程并发访问时的性能下降。</li>
</ul>
</li>
<li><p><strong>TreeMap</strong>：</p>
<ul>
<li>实现方式：基于红黑树的数据结构，通过键的自然顺序或者自定义比较器来维护键值对的有序性。</li>
<li>线程安全性：非线程安全，不支持并发访问。在多线程环境下使用时，需要通过外部同步机制来保证线程安全。</li>
<li>性能：在大多数操作上性能较HashMap略差，但是因为维护了有序性，适用于需要按顺序遍历键值对的场景。</li>
</ul>
</li>
<li><p><strong>ConcurrentHashMap</strong>：</p>
<ul>
<li>实现方式：基于分段锁（Segment）的数据结构，内部由多个哈希桶组成，每个桶都是一个独立的哈希表，相当于将一个大的哈希表分成了多个小的哈希表，每个小的哈希表都有自己的锁。</li>
<li>线程安全性：线程安全，支持高并发访问。ConcurrentHashMap通过分段锁来实现并发控制，只有操作同一个哈希桶的线程才会被阻塞，其他线程可以并发地访问不同的桶。</li>
<li>性能：在高并发环境下性能优于HashTable，相对于HashMap在并发情况下有更好的性能。在Java 8及以后的版本中，进一步优化了性能。</li>
</ul>
</li>
</ol>
<h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><ol>
<li><p><strong>核心线程数（corePoolSize）</strong>：</p>
<ul>
<li>线程池中保持的最小线程数。</li>
<li>当有新任务到来时，线程池会创建线程来处理任务，直到达到核心线程数。</li>
</ul>
</li>
<li><p><strong>最大线程数（maximumPoolSize）</strong>：</p>
<ul>
<li>线程池中允许的最大线程数。</li>
<li>当队列满时且线程数未达到最大线程数时，线程池会创建新线程处理任务。</li>
</ul>
</li>
<li><p><strong>保持活动时间（keepAliveTime）</strong>：</p>
<ul>
<li>当线程池中线程数量超过核心线程数时，多余的空闲线程在指定时间内会被销毁。</li>
</ul>
</li>
<li><p><strong>时间单位（unit）</strong>：</p>
<ul>
<li>TimeUnit枚举类型，指定时间的单位。</li>
</ul>
</li>
<li><p><strong>任务队列（workQueue）</strong>：</p>
<ul>
<li>用于存储等待执行的任务的队列。</li>
<li>有多种类型的任务队列可供选择，如有界队列、无界队列和优先级队列等。</li>
</ul>
</li>
<li><p><strong>线程工厂（workQueue）</strong>：</p>
<ul>
<li>定义创建线程的方式。</li>
</ul>
</li>
<li><p><strong>拒绝策略（RejectedExecutionHandler）</strong>：</p>
<ul>
<li>当任务无法被接收时采取的策略。</li>
<li>常见的策略包括抛出异常、直接丢弃任务、丢弃队列中最老的任务和调用任务执行者的线程来执行任务。</li>
</ul>
</li>
</ol>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li><p><strong>线程池初始化</strong>：</p>
<ul>
<li>在初始化阶段，根据传入的参数创建一定数量的线程，并将它们添加到线程池中。</li>
<li>初始时创建的线程数量等于核心线程数。</li>
</ul>
</li>
<li><p><strong>任务执行</strong>：</p>
<ul>
<li>当有任务提交给线程池时，线程池会根据当前线程池状态和任务队列状态来决定如何处理任务。</li>
<li>如果线程池中的线程数小于核心线程数，新任务将会创建一个线程来执行。</li>
<li>如果线程池中的线程数达到核心线程数，新任务会被放入任务队列中等待执行。</li>
<li>如果任务队列已满，且线程数未达到最大线程数，则创建新线程执行任务。</li>
<li>如果线程池中的线程数达到最大线程数，新任务会被拒绝执行。</li>
</ul>
</li>
<li><p><strong>线程池扩容和缩容</strong>：</p>
<ul>
<li>当任务队列已满且线程数未达到最大线程数时，线程池会创建新线程执行任务，直到达到最大线程数。</li>
<li>当线程池中的线程数超过核心线程数且空闲时间超过保持活动时间时，多余的空闲线程会被销毁。</li>
</ul>
</li>
<li><p><strong>任务执行完成</strong>：</p>
<ul>
<li>当任务执行完成后，线程池会将线程放回线程池中以便复用，而不是立即销毁。</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/03/28/JVM%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/28/JVM%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">JVM基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-28 18:27:19" itemprop="dateCreated datePublished" datetime="2024-03-28T18:27:19+08:00">2024-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-29 18:25:49" itemprop="dateModified" datetime="2024-03-29T18:25:49+08:00">2024-03-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机（Java Virtual<br>Machine，JVM）是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟计算机功能来实现的，JVM屏蔽了与具体操作系统平台相关的信息，Java程序只需生成在Java虚拟机上运行的字节码，就可以在多种平台上不加修改的运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h3 id="JRE、JDK、JVM关系"><a href="#JRE、JDK、JVM关系" class="headerlink" title="JRE、JDK、JVM关系"></a>JRE、JDK、JVM关系</h3><ol>
<li>JRE（Java Runtime Environment）：Java运行环境，所有的Java程序都要在JRE下才能运行。</li>
<li>JDK（Java Development Kit）：Java开发工具包，它是程序开发者用来编译、调试Java程序，它也是Java程序，也需要JRE才能运行。</li>
<li>JVM（Java Virtual Machine）：Java虚拟机，它是JRE的一部分，一个虚构出来的计算机，它支持跨平台。</li>
</ol>
<h3 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h3><ol>
<li>类加载器：用于加载.class文件</li>
<li>运行时数据区：包含方法区、堆、虚拟机栈、程序计数器、本地方法栈</li>
<li>执行引擎：用于执行字节码或本地方法，包括及时编译器和垃圾回收器</li>
</ol>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>Java7之前在方法区中有一个叫“运行时常量池”的区域，主要用来存放编译器生成的各种字面量和符号引用，在类加载完成后载入到运行时常量池中以便后续使用；</p>
<p>Java7时已从方法区转移到堆内存和本地内存，如符号引用转移到本地内存、字符串常量池和类静态变量转移到堆内存；</p>
<p>Java8及之后方法区更改为元数据空间，直接使用本地内存来存储类的元数据信息。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>线程共享，唯一用途是存放对象实例，因此也是垃圾收集器管理的主要区域。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有，用于描述Java方法执行的内存模式。每个方法在执行的同时会生成一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用至执行完成，对应于一个栈帧在虚拟机栈中从入栈到出栈。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程私有，当前线程所执行字节码的行号指示器。每一个线程都有一个独立的程序计数器，线程的阻塞、恢复、挂起等一系列操作都需要程序计数器的参与，因此必须是线程私有的。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>线程私有，与虚拟机栈的作用相似，只不过虚拟机栈为执行Java方法服务，而本地方法栈为执行本地方法服务，比如在Java中调用C&#x2F;C++。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>实现通过类的全限定名获取类的二进制字节流的代码块叫做类加载器。</p>
<p>Java中的所有类都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的职责就是把.class文件从硬盘读取到内存中。</p>
<p>为了节省内存开销，Java类的加载是动态的，并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类完全加载到JVM中，其他类在需要的时候才加载。</p>
<h3 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h3><ol>
<li>隐式装载：如通过new关键字生成对象</li>
<li>显式装载：如通过反射、class.ForName()等方法生成对象</li>
</ol>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><ol>
<li>启动类加载器：用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器：用来加载Java的扩展库。</li>
<li>系统类加载器：用来加载ClassPath环境变量配置的类库，可以通过ClassLoader.getSystemClassLoader()获取。</li>
<li>自定义类加载器：负责加载指定的特殊目录下的字节码文件，需要继承ClassLoader抽象类并重写findClass()和loadClass()方法，由此可以打破双亲委派模型。</li>
</ol>
<h3 id="类加载机制（双亲委派）"><a href="#类加载机制（双亲委派）" class="headerlink" title="类加载机制（双亲委派）"></a>类加载机制（双亲委派）</h3><p>类的加载是通过双亲委派模型来完成的。当一个类加载器收到加载某个类的请求时，会先将这个请求委派给父类加载器，只有当父类加载器反馈自己无法完成加载请求时，子类加载器才会尝试自己去加载。因此所有的类加载请求都会向上委派直到到达顶层的启动类加载器中。</p>
<p>使用双亲委派模型的好处：</p>
<ol>
<li>避免自定义的类动态替换掉Java核心库的类</li>
<li>避免类的重复加载</li>
</ol>
<h3 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">加载--&gt;验证--&gt;准备--&gt;解析--&gt;初始化--&gt;使用--&gt;卸载</span><br></pre></td></tr></table></figure>

<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>虚拟机把描述类的数据从.class文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<ol>
<li>加载：类加载器获取二进制字节流，将静态存储结构转化为方法区的运行时数据结构，并生成此类的Class对象</li>
<li>验证：验证文件格式、元数据、字节码、符号引用，确保字节流包含的信息符合当前虚拟机的要求</li>
<li>准备：在方法区为类静态变量分配内存并设置其初始值</li>
<li>解析：将符号引用替换为直接引用</li>
<li>初始化：为类的静态变量赋值、执行静态代码块和构造函数</li>
</ol>
<h3 id="类引用类型"><a href="#类引用类型" class="headerlink" title="类引用类型"></a>类引用类型</h3><ol>
<li>强引用：默认情况下，对象采用的均为强引用</li>
<li>软引用：SoftReference类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</li>
<li>弱引用：WeakReference类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</li>
<li>虚引用：PhantomReference类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是自动管理虚拟机内存的系统，对于垃圾对象的清除、存活对象的管理、内存碎片的回收都是由它负责。</p>
<p>程序计数器、虚拟机栈、本地方法栈是线程私有的，所以会随着线程结束而消亡，但是堆和方法区是线程共享的，在程序处于运行期才知道哪些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收所关注的就是这部分内存。</p>
<h3 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h3><p>进行垃圾回收前要判断哪些对象应该被回收。</p>
<h4 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h4><p>给对象添加引用计数器，当对象被引用时计数器加1，当引用失效时计数器减1，当计数器为0时表示对象可以被回收。</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>通过GC Roots对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连的时候说明对象不可用，可以被回收。</p>
<p>可以作为GC Roots的对象：</p>
<ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中native方法引用的对象</li>
<li>存活的线程</li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>先根据可达性分析标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>先根据可达性分析标记出所有需要回收的对象，标记完成后让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>按照容量划分两个大小相等的内存区域，每次只使用其中一个区域.当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。</p>
<h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4><p>根据对象存活周期的不同将内存划分为新生代和老年代，新生代基本采用复制算法，里面包含eden、to survivor、from survivor三个分区，老年代采用标记整理算法。</p>
<ol>
<li>当eden和from survivor分区的内存不足时把其中存活的对象复制到to survivor分区中，并清空eden和from survivor分区；</li>
<li>to survivor分区和from survivor分区交换；</li>
<li>在第一步中，从from survivor分区移动到to survivor分区的对象年龄加1，当年龄到达配置的值时（默认15）升级为老年代，大对象会直接进入老年代。</li>
<li>当老年代内存占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法，最后回到第一步。</li>
</ol>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是垃圾收集算法的具体实现，可以分为分代收集器和分区收集器。</p>
<p>分代收集器：Serial、ParNew、Parallel Scavenge、CMS、Serial Old、Parallel Old</p>
<p>分区收集器：G1</p>
<h4 id="Serial收集器-复制算法"><a href="#Serial收集器-复制算法" class="headerlink" title="Serial收集器(复制算法)"></a>Serial收集器(复制算法)</h4><p>新生代单线程收集器，简单高效，适合单线程环境和对暂停时间要求不高的应用场景。</p>
<h4 id="ParNew收集器-复制算法"><a href="#ParNew收集器-复制算法" class="headerlink" title="ParNew收集器(复制算法)"></a>ParNew收集器(复制算法)</h4><p>新生代收并行收集器，是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现，可用于搭配CMS的新生代收集器</p>
<h4 id="Parallel-Scavenge收集器-复制算法"><a href="#Parallel-Scavenge收集器-复制算法" class="headerlink" title="Parallel Scavenge收集器(复制算法)"></a>Parallel Scavenge收集器(复制算法)</h4><p>新生代并行收集器，追求高吞吐量，高效利用CPU，尽快完成程序的运算任务，适合后台应用等对交互响应 要求不高的场景</p>
<p>吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)</p>
<h4 id="Serial-Old收集器-标记-整理算法"><a href="#Serial-Old收集器-标记-整理算法" class="headerlink" title="Serial Old收集器(标记-整理算法)"></a>Serial Old收集器(标记-整理算法)</h4><p>老年代单线程收集器，Serial收集器的老年代版本</p>
<h4 id="Parallel-Old收集器-标记-整理算法"><a href="#Parallel-Old收集器-标记-整理算法" class="headerlink" title="Parallel Old收集器(标记-整理算法)"></a>Parallel Old收集器(标记-整理算法)</h4><p>老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本</p>
<h4 id="CMS-Concurrent-Mark-Sweep-收集器-并发标记清除回收器"><a href="#CMS-Concurrent-Mark-Sweep-收集器-并发标记清除回收器" class="headerlink" title="CMS(Concurrent Mark Sweep)收集器(并发标记清除回收器)"></a>CMS(Concurrent Mark Sweep)收集器(并发标记清除回收器)</h4><p>老年代并发收集器，以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器，还会产生大量内存碎片</p>
<ol>
<li>初始标记：仅标记Gc Root节点直接关联的对象，需要停顿用户线程但是耗时很短</li>
<li>并发标记：从Gc Roots节点出发，对整个堆空间进行可达性分析，标记所有存活对象，和用户线程并发执行</li>
<li>重新标记：通过增量更新算法修正并发标记阶段因用户线程造成的标记改动的那部分对象</li>
<li>并发清除：清除标记的存活对象外的垃圾对象</li>
</ol>
<h4 id="G1-Garbage-First-收集器-标记-整理算法"><a href="#G1-Garbage-First-收集器-标记-整理算法" class="headerlink" title="G1(Garbage First)收集器(标记-整理算法)"></a>G1(Garbage First)收集器(标记-整理算法)</h4><p>Java堆并发分区回收收集器，在不牺牲吞吐量前提下实现低停顿垃圾回收，也不会产生内存碎片</p>
<p>G1将整个Java堆划分为多个大小相等的独立区域，叫做Region，新生代和老年代就是由一个个Region动态组成的区域，它们可以是不连续的区间。<br>每一个Region都可以根据需要，扮演新生代的Eden空间，Survivor空间，或者老年代空间，除此之外它还有一类专门用来存储大对象的特殊区域叫做Humongous。</p>
<ol>
<li>初始标记：仅标记和Gc Roots节点直接关联的对象，需要停顿用户线程但是耗时很短</li>
<li>并发标记：从Gc Roots节点出发，对整个堆空间进行可达性分析，标记所有存活对象，和用户线程并发执行，用户线程会根据第一步标记对象的Region在正确可用的Region中创建新对象</li>
<li>最终标记：需要停顿用户线程但是耗时很短，通过原始快照算法用户修正并发标记阶段中仍然存在改动的对象</li>
<li>筛选回收：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划：将一部分Region中存活的对象复制到空Region中，再清除原Region的空间。</li>
</ol>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="minor-GC"><a href="#minor-GC" class="headerlink" title="minor GC"></a>minor GC</h4><p>新生代GC，清理整个新生代。当eden、from survivor、to survivor分区内存不足时触发</p>
<h4 id="major-GC"><a href="#major-GC" class="headerlink" title="major GC"></a>major GC</h4><p>老年代GC，清理整个老年代。当老年代分区不足时触发</p>
<h4 id="mixed-GC"><a href="#mixed-GC" class="headerlink" title="mixed GC"></a>mixed GC</h4><p>混合GC，清理整个新生代和部分老年代空间</p>
<h4 id="full-GC"><a href="#full-GC" class="headerlink" title="full GC"></a>full GC</h4><p>全局GC，清理整个新生代、老年代和元空间</p>
<h2 id="基本命令和工具"><a href="#基本命令和工具" class="headerlink" title="基本命令和工具"></a>基本命令和工具</h2><ol>
<li>标准参数（-），所有的JVM实现都必须实现这些参数的功能，而且向后兼容</li>
<li>非标准参数（-X），默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容</li>
<li>非Stable参数（-XX），此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用（但是，这些参数往往是非常有用的）</li>
<li>查看所有Java进程的所有启动参数和配置参数：<code>ps -ef | grep java</code></li>
</ol>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ol>
<li>java 运行.class和.jar</li>
<li>javac 编译.java成.class</li>
<li>javap 反编译.class成.java</li>
<li>jps 显示虚拟机进程</li>
<li>jstat 监视虚拟机运行时状态信息</li>
<li>jmap 用于生成heap dump文件</li>
<li>jhat 分析dump文件</li>
<li>jstack 生成java虚拟机当前时刻的线程快照</li>
<li>jinfo 实时查看和调整虚拟机运行参数</li>
</ol>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol>
<li>jconsole：用于对JVM中的内存、线程和类等进行监控</li>
<li>jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序 死锁、监控内存的变化、gc变化等。</li>
</ol>
<h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>堆内存初始大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大内存</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代内存</td>
</tr>
<tr>
<td>-Xss</td>
<td>栈内存大小</td>
</tr>
<tr>
<td>-XX:NewRatio&#x3D;n</td>
<td>新生代:老年代 &#x3D; 1:n</td>
</tr>
<tr>
<td>-XX:SurvivorRatio&#x3D;n</td>
<td>新生代分区比例：Eden:S0:S1 &#x3D; n:1:1</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>java7设置方法区初始大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>java7设置方法区最大大小</td>
</tr>
<tr>
<td>-XX:MetaspaceSize</td>
<td>java8设置元空间大小</td>
</tr>
<tr>
<td>-XX:MaxMetaspaceSize</td>
<td>java8设置元空间最大大小</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize</td>
<td>直接内存</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>使用G1垃圾回收器</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾对象最大年龄</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>老年代内存回收阈值</td>
</tr>
<tr>
<td>-XX:DisableExplicitGC</td>
<td>禁止运行期显式地调用System.gc()来触发full GC</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>GC最大执行时间&#x2F;停顿时间</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintGC</td>
<td>输出简要GC日志</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出详细GC日志</td>
</tr>
<tr>
<td>-Xloggc:gc.log</td>
<td>输出GC日志到gc.log文件</td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td>输出GC时间：时间戳</td>
</tr>
<tr>
<td>-XX:+PrintGCDateStamps</td>
<td>输出GC时间：日期</td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>执行GC前后打印堆信息</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>输出简要GC日志</td>
</tr>
<tr>
<td>-XX:+PrintReferenceGC</td>
<td>打印新生代各个引用的数量和时长</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>出现OOM时输出堆内信息的快照</td>
</tr>
<tr>
<td>-XX:HeapDumpPath&#x3D;.&#x2F;</td>
<td>指定快照位置</td>
</tr>
<tr>
<td>-XX:OnOutOfMemoryError</td>
<td>出现OOM时运行指定程序&#x2F;脚步</td>
</tr>
</tbody></table>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">–Xms4g -Xmx4g –Xmn1200m –Xss512k</span><br><span class="line">-XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span><br><span class="line">-XX:PermSize=100m -XX:MaxPermSize=256m</span><br><span class="line">-XX:MaxDirectMemorySize=1G -XX:+DisableExplicitGC</span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/home/log/gc.log</span><br><span class="line">-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=512k</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">JTRAINBOW</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
