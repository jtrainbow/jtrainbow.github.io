<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jtrainbow.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Spring是一个轻量级的开源框架，以IOC和AOP为内核，它提供了展示层、持久层、业务层事物管理等众多企业级应用技术，并且可以整合众多主流的开源框架和类库，能简化开发、方便解耦和测试。 体系结构Spring框架提供了大概20个模块，按照功能可划分为五个大类：  Core Container：Beans Core Context SpEL AOP：AOP Aspects Instrumentati">
<meta property="og:type" content="article">
<meta property="og:title" content="SPRING">
<meta property="og:url" content="https://jtrainbow.github.io/2024/04/19/Spring/index.html">
<meta property="og:site_name" content="JTRAINBOWの博客">
<meta property="og:description" content="Spring是一个轻量级的开源框架，以IOC和AOP为内核，它提供了展示层、持久层、业务层事物管理等众多企业级应用技术，并且可以整合众多主流的开源框架和类库，能简化开发、方便解耦和测试。 体系结构Spring框架提供了大概20个模块，按照功能可划分为五个大类：  Core Container：Beans Core Context SpEL AOP：AOP Aspects Instrumentati">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-19T13:37:44.162Z">
<meta property="article:modified_time" content="2024-05-04T10:27:05.388Z">
<meta property="article:author" content="JTRAINBOW">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jtrainbow.github.io/2024/04/19/Spring/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jtrainbow.github.io/2024/04/19/Spring/","path":"2024/04/19/Spring/","title":"SPRING"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SPRING | JTRAINBOWの博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">JTRAINBOWの博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Beans"><span class="nav-number">2.</span> <span class="nav-text">Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Bean"><span class="nav-number">2.1.</span> <span class="nav-text">定义Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.2.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.3.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">2.4.</span> <span class="nav-text">循环依赖问题&#x2F;三级缓存机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC"><span class="nav-number">3.</span> <span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DI"><span class="nav-number">3.1.</span> <span class="nav-text">DI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanDefinition"><span class="nav-number">3.2.</span> <span class="nav-text">BeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">IOC流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory"><span class="nav-number">3.4.</span> <span class="nav-text">BeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext"><span class="nav-number">3.5.</span> <span class="nav-text">ApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpEL"><span class="nav-number">4.</span> <span class="nav-text">SpEL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP"><span class="nav-number">5.</span> <span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP%E7%BB%84%E6%88%90"><span class="nav-number">5.1.</span> <span class="nav-text">Spring AOP组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">5.2.1.</span> <span class="nav-text">动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="nav-number">5.2.2.</span> <span class="nav-text">拦截器链</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transactions"><span class="nav-number">6.</span> <span class="nav-text">Transactions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ACID"><span class="nav-number">6.1.</span> <span class="nav-text">ACID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.</span> <span class="nav-text">隔离性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">6.3.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81"><span class="nav-number">6.4.</span> <span class="nav-text">spring事务支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">6.5.</span> <span class="nav-text">spring事务管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.</span> <span class="nav-text">Spring事务失效问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC"><span class="nav-number">7.</span> <span class="nav-text">SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC"><span class="nav-number">7.1.</span> <span class="nav-text">MVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet"><span class="nav-number">7.2.</span> <span class="nav-text">Servlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket"><span class="nav-number">8.</span> <span class="nav-text">websocket</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">8.1.</span> <span class="nav-text">即时通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F"><span class="nav-number">9.</span> <span class="nav-text">跨域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">9.1.</span> <span class="nav-text">同源策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS"><span class="nav-number">9.2.</span> <span class="nav-text">CORS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring%E8%B7%A8%E5%9F%9F"><span class="nav-number">9.3.</span> <span class="nav-text">spring跨域</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JTRAINBOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jtrainbow.github.io/2024/04/19/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JTRAINBOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="SPRING | JTRAINBOWの博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SPRING
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-19 21:37:44" itemprop="dateCreated datePublished" datetime="2024-04-19T21:37:44+08:00">2024-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-04 18:27:05" itemprop="dateModified" datetime="2024-05-04T18:27:05+08:00">2024-05-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Spring是一个轻量级的开源框架，以IOC和AOP为内核，它提供了展示层、持久层、业务层事物管理等众多企业级应用技术，并且可以整合众多主流的开源框架和类库，能简化开发、方便解耦和测试。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Spring框架提供了大概20个模块，按照功能可划分为五个大类：</p>
<ol>
<li><code>Core Container</code>：<code>Beans</code> <code>Core</code> <code>Context</code> <code>SpEL</code></li>
<li><code>AOP</code>：<code>AOP</code> <code>Aspects</code> <code>Instrumentation</code> <code>Messaging</code></li>
<li><code>Data Access/Integration</code>：<code>JDBC</code> <code>ORM</code> <code>OXM</code> <code>JMS</code> <code>Transactions</code></li>
<li><code>Web</code>： <code>WebSocket</code> <code>Servlet</code> <code>Web</code> <code>Portlet</code></li>
<li><code>Test</code></li>
</ol>
<h2 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h2><ol>
<li>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。</li>
<li>bean是由Spring IoC容器自动完成实例化、组装和管理的对象。</li>
<li>根据XML配置文件或者注解标注一个类可以告知Spring IOC容器这是一个Bean。</li>
</ol>
<h3 id="定义Bean"><a href="#定义Bean" class="headerlink" title="定义Bean"></a>定义Bean</h3><ol>
<li>XML配置文件</li>
<li>注解：@Component、@ComponentScan、@Configuration、@Bean、@DependOn等</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>可以在XML配置文件中通过scope属性或者@Scope注解声明bean的作用域。</p>
<ol>
<li><code>singleton</code><br>：默认值，单例作用域，在容器中仅存在一个共享的单例bean实例，单例bean在容器创建时就会实例化一个bean对象，但也可以通过XML配置文件的lazy-init属性或者@Lazy注解延迟到第一次使用bean的时候再初始化；</li>
<li><code>prototype</code>：原型作用域，每次获取都会返回一个新的bean实例，原型类型的bean在容器创建时不会实例化，而是在使用Bean的时候才创建一个对象；</li>
<li><code>request</code>：HTTP Request作用域，每一次HTTP请求都会产生一个新的bean实例，该实例只在当前请求内有效，请求结束后就会销毁；</li>
<li><code>session</code>：HTTP Session作用域，在同一个HTTP Session范围内只会生成一个bean实例，回话结束后实例就会销毁；</li>
<li><code>application</code>：表示在一次ServletContext内，创建bean的一个实例，并且该实例仅在当前ServletContext内有效。</li>
<li><code>websocket</code>：表示在一次WebSocket session内，创建bean的一个实例，并且该实例仅在当前WebSocket session内有效。</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Spring Bean的生命周期是指Bean在Spring容器中从创建到销毁的整个管理过程。</p>
<ol>
<li>实例化：容器在启动后，会通过XML配置文件或者注解找到定义成Bean的类，这些类的元数据被封装在实现了BeanDefinition接口的类中，然后创建一个bean实例；<ul>
<li>构造方法：将bean的无参构造方法通过反射创建实例</li>
<li>静态工厂：在对象工厂声明创建bean的静态方法，实例化时指定工厂类和工厂方法</li>
<li>实例工厂：<ul>
<li>在对象工厂声明创建bean的非静态方法，实例化时指定工厂bean和工厂方法</li>
<li>对象工厂类实现FactoryBean接口</li>
</ul>
</li>
</ul>
</li>
<li>注入属性：如果涉及属性的设置则通过set方法注入属性的值</li>
<li>初始化：<ul>
<li>如果实现了*Aware接口则调用接口实现的方法；</li>
<li>如果使用了@PostConstruct注解则执行指定的方法</li>
<li>如果实现了InitializingBean接口则执行指定afterPropertiesSet方法；</li>
<li>如果配置文件指定了init-method则执行指定的方法；<ul>
<li>至此就完成初始化工作，后续可以通过后置处理器做一些自定义扩展，比如创建代理</li>
</ul>
</li>
<li>如果实现了BeanPostProcessor接口则会在初始化前后处理；</li>
<li>如果实现了Destruction接口则会注册销毁bean的回调方法；</li>
</ul>
</li>
<li>调用：通过@Autowired注解或者ApplicationContext的getBean()获取对象实例并且使用；</li>
<li>销毁：关闭应用时spring调用ApplicationContext的close()来关闭容器则会销毁Bean；<ul>
<li>如果实现了Destruction接口则会调用回调方法；</li>
<li>如果使用了@PreDestroy注解则执行指定的方法；</li>
<li>如果实现了DisposableBean接口则调用destroy()的方法；</li>
<li>如果配置文件指定了destroy-method则执行指定的销毁方法；</li>
</ul>
</li>
</ol>
<h3 id="循环依赖问题-三级缓存机制"><a href="#循环依赖问题-三级缓存机制" class="headerlink" title="循环依赖问题&#x2F;三级缓存机制"></a>循环依赖问题&#x2F;三级缓存机制</h3><ol>
<li><p>循环依赖：在Beans的创建过程中，可能出现多个Bean相互依赖的关系，Spring IOC容器在创建A时，发现需要注入B转而去创建B，但创建B时又发现需要注入A转而去创建A，因此出现了死循环。</p>
</li>
<li><p>三级缓存：Spring通过引入三级缓存机制来解决循环依赖问题：</p>
<ul>
<li>一级缓存（singletonObjects）保存完成初始化的bean</li>
<li>二级缓存（earlySingletonObjects）保存已经实例化但未完成初始化的bean</li>
<li>三级缓存（singletonFactories）保存创建bean的ObjectFactory</li>
</ul>
</li>
</ol>
<p>假设beanA和beanC相互依赖：</p>
<ol>
<li><p>当获取beanA时，会依次从一级缓存、二级缓存、三级缓存、父类对象工厂中获取实例，如果获取不到则根据BeanDefinition和反射创建实例，并把beanA的ObjectFactory对象存入三级缓存<br>为beanA注入属性时发现需要注入beanC，于是去获取beanC</p>
</li>
<li><p>当获取beanC时，会依次从一级缓存、二级缓存、三级缓存、父类对象工厂中获取实例，如果获取不到则根据BeanDefinition和反射创建实例，并把beanC的ObjectFactory对象存入三级缓存<br>为beanC注入属性时发现需要注入beanA，于是去获取beanA</p>
</li>
<li><p>依次从一级缓存、二级缓存、三级缓存、父类对象工厂中获取实例beanA的实例，这时三级缓存中存在beanA的ObjectFactory对象，于是通过getObject方法获取beanA的实例或者代理实例<br>然后把实例存入二级缓存，并移除beanA的三级缓存</p>
</li>
<li><p>beanC成功注入beanA，完成初始化操作和后置处理，然后把beanC的实例或者代理实例保存到一级缓存，并移除三级缓存</p>
</li>
<li><p>beanA成功注入beanC，完成初始化操作和后置处理时，发现beanA在二级缓存，于是取出二级缓存并替换掉，最后移除二级缓存并保存到一级缓存</p>
</li>
</ol>
<p>三级缓存机制的理论依据基于Java的引用传递，当获取对象的引用时可以让对象的属性延迟设置，因此三级缓存只能解决属性注入和setter注入的循环依赖，无法解决有参构造方法注入的循环依赖。</p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC（Inversion of Control，控制反转）是一种设计思想，简单来说就是把一个复杂的系统分解成多个相互合作、相互依赖的对象，这些对象通过第三方来封装，从而降低了对象之间的耦合度和解决问题的复杂度，而且可以灵活的被重用和扩展。<br>在spring中，这个第三方就是Spring IOC容器，而容器的底层则是对象工厂。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>DI（Dependency Injection，依赖注入）是指由IoC容器在运行期间，动态的将某种依赖关系注入到对象之中。</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>BeanDefinition是定义Bean的元数据信息的接口，包含了bean的全限定名、构造方法、属性、作用域、懒加载等信息，spring通过BeanDefinitionReader找到并读取所有定义成bean的类，然后将其转换成BeanDefinition对象，最后根据BeanDefinition来创建bean。</p>
<h3 id="IOC流程"><a href="#IOC流程" class="headerlink" title="IOC流程"></a>IOC流程</h3><p>当启动spring应用时，IOC容器也会一起启动，它的启动流程可以归纳为三个步骤：</p>
<ol>
<li>初始化容器，把内置的BeanPostProcessor的BeanDefinition注册到容器；</li>
<li>获取所有配置类的BeanDefinition并注册到容器；</li>
<li>调用refresh()方法刷新容器。<ul>
<li><code>prepareRefresh</code>：刷新前的预处理，设置当前时间和容器状态</li>
<li><code>obtainFreshBeanFactory</code>：创建BeanFactory实例</li>
<li><code>prepareBeanFactory</code>：设置BeanFactory，比如当前上下文的类加载器、系统环境和系统属性</li>
<li><code>postProcessBeanFactory</code>：注册内置后置处理</li>
<li><code>invokeBeanFactoryPostProcessors</code>：调用内置后置处理</li>
<li><code>registerBeanPostProcessors</code>：注册其他后置处理器</li>
<li><code>initMessageSource</code>：初始化消息资源组件，主要作用是从配置文件读取国际化配置</li>
<li><code>initApplicationEventMulticaster</code>：初始化事件派发器</li>
<li><code>registerListeners</code>：注册监听器，并把监听器添加到事件派发器</li>
<li><code>finishBeanFactoryInitialization</code>：实例化所有非懒加载非抽象类的单例bean并放入IOC容器</li>
<li><code>finishRefresh</code>：完成容器初始化后的一些操作，如清除资源缓存、发布容器刷新完成事件</li>
</ul>
</li>
</ol>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>IOC容器的基本实现，是Spring内部使用的接口，不提供给开发人员使用，在加载配置文件时不会创建对象，在获取对象时才采取创建对象。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>BeanFactory接口的子接口，提供更多强大的功能，一般由开发人员使用。接口提供了bean基础性操作同时，扩展了国际化等功能。ApplicationContext接口在加载配置文件时候就会创建配置文件中的对象，存放IOC容器当中。</p>
<h2 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h2><p>SpEL（Spring Expression Language，表达式语言）能够在运行时构建复杂表达式, 存取对象属性、调用对象方法等</p>
<ol>
<li>所有的SpEL都支持XML和Annotation两种方式，使用的格式均为：<code>#&#123;SpEL expression&#125;</code></li>
<li>通过<code>new SpelExpressionParser()</code>创建解析器</li>
</ol>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Program，面向切面编程）是通过预编译和运行时动态代理来实现统一维护程序功能的技术思想，是OOP（Object Oriented Programming，面向对象）思想的延伸。</p>
<p>在OOP中以类&#x2F;class作为基本单元，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的纵向逻辑划分；在AOP中以切面&#x2F;Aspect作为基本单元，针对业务处理过程中的重复代码进行提取，并通过代理模式，在不改变原有代码逻辑的基础上，动态地将重复代码或者增强处理切入到指定的位置。</p>
<p>在Spring中，AOP由Spring AOP框架实现。</p>
<h3 id="Spring-AOP组成"><a href="#Spring-AOP组成" class="headerlink" title="Spring AOP组成"></a>Spring AOP组成</h3><p>AOP的基本单元是Aspect，它由JoinPoint（连接点）、PointCut（切点）和Advice（通知处理）三个部分组成。</p>
<ol>
<li><code>Aspect</code>：切面定义了一个AOP的功能。</li>
<li><code>JoinPoint</code>：连接点是程序运行过程中可识别的点（调用方法、抛出异常、修改字段等），这些点可以用来作为AOP切入点将切面织入指定位置，而连接点中包含了切入点的对象、方法、属性等上下文信息。</li>
<li><code>PointCut</code>：切点的作用是提供一组规则来匹配连接点，并给所有满足规则的连接点添加通知处理</li>
<li><code>Advice</code>：通知处理是AOP实际完成增强处理的部分，并且可以在指定时机执行指定的处理。<ul>
<li><code>Before</code>：前置处理</li>
<li><code>After</code>：后置处理</li>
<li><code>Around</code>：环绕处理</li>
<li><code>AfterReturning</code>：后置返回通知</li>
<li><code>AfterThrowing</code>：异常处理</li>
</ul>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Spring AOP通过动态代理+拦截器链的方式实现。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ol>
<li>JDK动态代理：基于反射和实现接口<ul>
<li>Proxy.newProxyInstance()创建被代理类的代理类</li>
<li>代理类实现InvocationHandler接口的invoke()方法，通过反射调用被代理类的目标方法</li>
</ul>
</li>
<li>CGLIB动态代理：基于字节码和子类继承<ul>
<li>Enhancer创建被代理类的代理类</li>
<li>代理类实现MethodInterceptor接口的intercept()方法，通过父类方法调用被代理类的目标方法</li>
</ul>
</li>
<li>非提前生成代理：初始化后<ul>
<li>在bean完成初始化后，会执行所有的BeanPostProcessor后置处理，</li>
<li>其中AnnotationAwareAspectJAutoProxyCreator后置处理中wrapIfNecessary()<br>方法实现了aop动态代理，能返回bean的实例或者代理类实例并替换原来的bean</li>
</ul>
</li>
<li>提前生成代理：注入属性时<ul>
<li>提前生成代理主要是为了解决循环依赖问题</li>
<li>当beanC获取beanA时 通过getSingleton()方法从三级缓存中获取beanA的ObjectFactory对象</li>
<li>ObjectFactory对象的getObject()方法是执行的getEarlyBeanReference()方法</li>
<li>这个方法会调用所有实现了SmartInstantiationAwareBeanPostProcessor接口的后置处理器的getEarlyBeanReference()<br>方法，AnnotationAwareAspectJAutoProxyCreator后置处理器实现了SmartInstantiationAwareBeanPostProcessor接口，它的getEarlyBeanReference()<br>方法 中调用的wrapIfNecessary()<br>方法实现了aop动态代理，能返回bean的实例或者代理类实例并替换原来的bean</li>
</ul>
</li>
<li>wrapIfNecessary()<ul>
<li>如果传入的对象已经处理过、已经创建了代理类、是spring内置的bean、应该忽略，则直接返回</li>
<li>任意一项不满足，则创建代理类工厂，创建并返回代理类</li>
</ul>
</li>
</ol>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><ol>
<li>在<code>Advice</code>中有多个增强处理方法，每个方法都有一个拦截器</li>
<li>在为切面类创建bean时，需要通过代理工厂为其创建代理类</li>
<li>代理工厂中封装了Advice的所有方法的advisors</li>
<li>在创建代理类时，会按照顺序创建advisors的拦截器链</li>
<li>不同切面默认按照字典排序，也可以使用<code>@Order</code>注解或实现<code>Order</code>接口，数值越小优先级越高</li>
<li>同一切面多个相同<code>Advice</code>方法按照字典排序，不同<code>Advice</code>方法按照固定顺序<ul>
<li>环绕通知前置处理-&gt;前置处理-&gt;代理方法-&gt;后置处理-&gt;环绕通知后置处理-&gt;返回通知处理&#x2F;异常通知处理</li>
</ul>
</li>
</ol>
<h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>事务是关系型数据库的重要组成，用来确保应用程序数据的完整性和一致性。</p>
<p>在spring中，事务是访问和更新数据库中各种数据项的一个程序执行单元，当在数据库中更改数据成功时，在事务中更改的数据便会提交并且不再改变，否则事务就取消或者回滚，让更改的数据无效。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务具有四种特性：原子性、一致性、隔离型、持久性，即ACID特性</p>
<ol>
<li>原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。</li>
<li>一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。</li>
<li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。</li>
<li>持久性（Durability）：一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</li>
</ol>
<h3 id="隔离性问题"><a href="#隔离性问题" class="headerlink" title="隔离性问题"></a>隔离性问题</h3><p>事务的隔离性定义了并发事务互不干扰，但在不同的隔离级别下，仍有可能出现一些问题：</p>
<ol>
<li>脏读：事务A读取事务B未提交的数据后，事务B回滚数据，导致事务A读到的数据无效。</li>
<li>不可重复读：事务A多次查询同一数据，在查询间隔内事务B修改了数据，导致事务A得到了不同结果，</li>
<li>幻读：事务A多次范围查询同一组数据集，在查询间隔内事务B修改了数据集，导致事务A得到的数据集不一样。如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。</li>
</ol>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol>
<li>读未提交：最低的隔离级别<ul>
<li>当前事务可以看到其他事务未提交的修改</li>
<li>可能出现脏读、不可重复读和幻读</li>
</ul>
</li>
<li>读已提交：Oracle默认<ul>
<li>当前事务可以看到其他事务已提交的修改</li>
<li>可能出现不可重复读和幻读</li>
</ul>
</li>
<li>可重复读：Mysql默认<ul>
<li>一个事务多次查询同一数据能得到一致的结果，其他事务对同一数据的修改不会造成影响</li>
<li>可能出现幻读</li>
</ul>
</li>
<li>串行化：最高的隔离级别<ul>
<li>所有事务按照次序依次执行</li>
</ul>
</li>
</ol>
<p>不同的事务隔离级别提供了不同程度的隔离策略，以满足不同应用场景对于一致性和性能的需求，在选择事务隔离级别时，需要在数据一致性和系统性能之间进行权衡。</p>
<h3 id="spring事务支持"><a href="#spring事务支持" class="headerlink" title="spring事务支持"></a>spring事务支持</h3><ol>
<li>编程式：编程式事务管理是通过在业务代码中嵌入事务管理代码的方式实现的事务管理，灵活性高可以将事务精确到代码块级别，但难以维护。</li>
<li>声明式：基于AOP技术实现的事务管理，可以将事务管理和业务代码分开，并同一维护，只能控制方法级别的事务。<ul>
<li>基于XML配置</li>
<li>基于注解</li>
</ul>
</li>
</ol>
<h3 id="spring事务管理器"><a href="#spring事务管理器" class="headerlink" title="spring事务管理器"></a>spring事务管理器</h3><p>Spring基于AOP提供了多种事务管理器，其中包含了事务传播行为、隔离级别、只读和超时等属性，这些属性提供了事务应用的方法和描述策略，用于事务管理。</p>
<ol>
<li><code>PlatformTransactionManager</code>接口：用于管理事务<ul>
<li><code>getTransaction()</code>：获取事务状态信息</li>
<li><code>commit()</code>：提交事务</li>
<li><code>rollback()</code>：回滚事务</li>
</ul>
</li>
<li><code>TransactionDefinition</code>接口：用于描述事务属性<ul>
<li><code>getPropagationBehavior()</code>：事务传播行为<ul>
<li><code>PROPAGATION_REQUIRED</code>：支持当前事务，如果没有事务则创建新事务。</li>
<li><code>PROPAGATION_SUPPORTS</code>：支持当前事务，如果没有事务则以非事务方式执行。</li>
<li><code>PROPAGATION_MANDATORY</code>：支持当前事务，如果没有事务则抛出异常。</li>
<li><code>PROPAGATION_REQUIRES_NEW</code>：创建新事务，如果有当前事务，则将当前事务挂起。</li>
<li><code>PROPAGATION_NOT_SUPPORTED</code>：以非事务方式执行，如果有当前事务，则将当前事务挂起。</li>
<li><code>PROPAGATION_NEVER</code>：以非事务方式执行，如果存在事务则抛出异常。</li>
<li><code>PROPAGATION_NESTED</code><br>：如果当前存在事务，则执行一个嵌套事务，如果当前没有事务，则等同于REQUIRED。嵌套事务中，主事务包含多个子事务，每个子事务都可以单独提交和回滚。如果主事务失败，所有子事务都会回滚。</li>
</ul>
</li>
<li><code>getIsolationLevel()</code>：事务隔离级别<ul>
<li><code>ISOLATION_DEFAULT</code>：使用数据库默认级别</li>
<li><code>ISOLATION_READ_UNCOMMITTED</code>：读未提交</li>
<li><code>ISOLATION_READ_COMMITTED</code>：读已提交</li>
<li><code>ISOLATION_REPEATABLE_READ</code>：可重复读</li>
<li><code>ISOLATION_SERIALIZABLE</code>：串行化</li>
</ul>
</li>
<li><code>getTimeout()</code>：超时时机</li>
<li><code>isReadOnly()</code>：事务只读</li>
<li><code>getName()</code>：事务名称</li>
</ul>
</li>
<li><code>TransactionStatus</code>接口：用于控制和描述事务状态<ul>
<li><code>isNewTransaction()</code>：是否是新事务</li>
<li><code>hasSavepoint()</code>：是否有保存点</li>
<li><code>setRollbackOnly()</code>：设置回滚</li>
<li><code>isRollbackOnly()</code>：是否回滚</li>
<li><code>flush()</code>：刷新事务</li>
<li><code>isCompleted()</code>：事务是否完成</li>
</ul>
</li>
</ol>
<h3 id="Spring事务失效问题"><a href="#Spring事务失效问题" class="headerlink" title="Spring事务失效问题"></a>Spring事务失效问题</h3><p>Spring事务基于AOP动态代理和数据库本身。</p>
<ol>
<li>数据库不支持事务</li>
<li>多次持久化操作使用了不同的数据库连接</li>
<li>事务方法所在的类被final修饰导致不能生成代理</li>
<li>事务方法所在的类没有被SpringIOC容器管理</li>
<li>事务方法私有</li>
<li>事务方法异常不匹配，默认只处理运行时异常</li>
<li>类内部事务方法相互调用</li>
<li>事务传播机制不合理</li>
<li>多线程处理事务</li>
</ol>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC是Spring Framework提供的Web组件，是一个实现了MVC设计思想的框架，可以提供前端路由映射、视图解析等功能。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC是一种把软件划分成模型、视图、控制器三个部分的软件设计思想</p>
<ol>
<li>模型（model）：也就是javabean，用于业务逻辑处理、数据访问和存储</li>
<li>视图（view）：也就是html和jsp页面，用于展示数据和用户交互</li>
<li>控制器（controller）：也就是servlet和controller，用于接收和响应请求</li>
</ol>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是接收和响应请求的中间层，可以生成动态的Web内容以及交互式地浏览和生成数据。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>SpringMVC的实现原理由其核心组件按照一定的工作流程实现。</p>
<ol>
<li><code>DispatcherServlet</code>：负责调度其他组件</li>
<li><code>Handler</code>：处理器，完成具体的业务逻辑，相当于Servlet</li>
<li><code>HandlerMapping</code>：处理器映射器，映射不同的请求到不同的Handler</li>
<li><code>HandlerInterceptor</code>：处理器拦截器，可以在处理器前后做拦截处理</li>
<li><code>HandlerExecutionChain</code>：处理器执行链，由<code>Handler</code>和<code>HandlerInterceptor</code>组成</li>
<li><code>HandlerAdapter</code>：处理器适配器，完成数据验证、数据类型转换、数据封装等操作后执行<code>Handler</code></li>
<li><code>ModelAndView</code>：<code>Handler</code>的执行结果，封装了模型数据和视图信息</li>
<li><code>ViewResolver</code>：视图解析器，把逻辑视图解析成实际视图</li>
</ol>
<p>当<code>DispatcherServlet</code>接收到客户端请求后，首先根据请求信息调用<code>HandlerMapping</code>解析出包含了<code>Handler</code>和<code>HandlerInterceptor</code>的<code>HandlerExecutionChain</code><br>，然后由<code>HandlerAdapter</code>完成参数解析并根据<code>Handler</code>执行业务处理，处理完成后得到<code>ModelAndView</code>，再由<code>ViewResolver</code>解析出实际的<code>View</code>并返回给客户端</p>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>WebSocket是HTML5定义的一种新协议，基于TCP实现了浏览器与服务器的全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。</p>
<h3 id="即时通信"><a href="#即时通信" class="headerlink" title="即时通信"></a>即时通信</h3><ol>
<li>短轮询：客户端间隔较短的时间向服务端发送请求并立即返回响应</li>
<li>长轮询：客户端间隔较短的时间向服务端发送请求，服务端持续等待到满足一定条件后返回响应，或者等待超时断开连接</li>
<li>SSE长连接：客户端向服务端发送请求，服务端不关闭连接，而是通过SSE持续向客户端发送数据，需要注意超时时间、servlet和filter开启异步、nginx代理关闭缓存和缓冲区</li>
<li>websocket：客户端向服务端发送特殊请求建立长久连接，可以完成实时双向通信</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>JDK：@ServerEndpoint</li>
<li>Spring：@MessageMapping、@SubscribeMapping、@SendTo</li>
</ol>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ol>
<li>跨域问题由浏览器的同源策略引起，这是浏览器对javascript强制施加的安全限制</li>
<li>同源策略要求域名、端口、协议相同，否则就是跨域</li>
<li>跨域问题会限制读取Cookie、获取JS对象、发送Ajax请求</li>
</ol>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（跨域资源共享）是处理跨域问题的一种解决方案，通过在请求头中配置<code>Access-Control-Allow-Origin</code>属性进而允许浏览器忽略对指定域名发送跨域请求的限制。</p>
<ol>
<li><code>Access-Control-Allow-Origin</code>：允许指定域名跨域</li>
<li><code>Access-Control-Allow-Methods</code>：允许指定方法跨域</li>
<li><code>Access-Control-Allow-Headers</code>：允许指定请求头字段跨域</li>
<li><code>Access-Control-Max-Age</code>：OPTION预检测间隔时间</li>
</ol>
<p>可以在HTTP请求的发送、转发、响应任意阶段配置CORS</p>
<h3 id="spring跨域"><a href="#spring跨域" class="headerlink" title="spring跨域"></a>spring跨域</h3><ol>
<li><code>CorsFilter</code></li>
<li><code>WebMvcConfigurer</code></li>
<li><code>@CrossOrigin</code></li>
<li><code>response.addHeader</code></li>
<li><code>Filter</code></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/04/15/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="prev" title="java内存模型">
                  <i class="fa fa-angle-left"></i> java内存模型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/04/26/SpringBoot/" rel="next" title="SPRING BOOT">
                  SPRING BOOT <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">JTRAINBOW</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
